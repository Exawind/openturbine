<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kynema API: kynema::math Namespace Reference &mdash; Kynema 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Kynema
              <img src="../../_static/oturb_logo_v2.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../user/user.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theory/index.html">Theory Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Developer Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgement.html">Acknowledgements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Kynema</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Kynema API: kynema::math Namespace Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/doxygen/html/namespacekynema_1_1math.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="math-namespace-reference">
<h1>math Namespace Reference<a class="headerlink" href="#math-namespace-reference" title="Permalink to this heading"></a></h1>
<div class="doxygen-content docutils container">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kynema API: kynema::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Kynema API
   </div>
   <div id="projectbrief">A flexible multibody structural dynamics code for wind turbines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacekynema.html">kynema</a></li><li class="navelem"><a class="el" href="namespacekynema_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">kynema::math Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c8b96ab1fcaa05338745026f25e883c" id="r_a4c8b96ab1fcaa05338745026f25e883c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a4c8b96ab1fcaa05338745026f25e883c">LinearInterpWeights</a> (double x, std::span&lt; const double &gt; xs, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a4c8b96ab1fcaa05338745026f25e883c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weights for linear interpolation.  <br /></td></tr>
<tr class="separator:a4c8b96ab1fcaa05338745026f25e883c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af446ed12cbeafb698952c0dd51380a4e" id="r_af446ed12cbeafb698952c0dd51380a4e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#af446ed12cbeafb698952c0dd51380a4e">LinearInterp</a> (double x, std::span&lt; const double &gt; xs, std::span&lt; const double &gt; values)</td></tr>
<tr class="memdesc:af446ed12cbeafb698952c0dd51380a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes linear interpolation.  <br /></td></tr>
<tr class="separator:af446ed12cbeafb698952c0dd51380a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dd71b3ba890b71a34198d3da48125a" id="r_a36dd71b3ba890b71a34198d3da48125a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a36dd71b3ba890b71a34198d3da48125a">LagrangePolynomialInterpWeights</a> (double x, std::span&lt; const double &gt; xs, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a36dd71b3ba890b71a34198d3da48125a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weights for Lagrange polynomial interpolation.  <br /></td></tr>
<tr class="separator:a36dd71b3ba890b71a34198d3da48125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55aa78460bdbb9616c64bb8837da1f2c" id="r_a55aa78460bdbb9616c64bb8837da1f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a55aa78460bdbb9616c64bb8837da1f2c">LagrangePolynomialDerivWeights</a> (double x, std::span&lt; const double &gt; xs, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a55aa78460bdbb9616c64bb8837da1f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weights for Lagrange polynomial derivative interpolation.  <br /></td></tr>
<tr class="separator:a55aa78460bdbb9616c64bb8837da1f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f9db3bae76edd783981815a2c8b571" id="r_a42f9db3bae76edd783981815a2c8b571"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a42f9db3bae76edd783981815a2c8b571">LegendrePolynomial</a> (const size_t n, const double x)</td></tr>
<tr class="memdesc:a42f9db3bae76edd783981815a2c8b571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the value of Legendre polynomial of order n at point x.  <br /></td></tr>
<tr class="separator:a42f9db3bae76edd783981815a2c8b571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30df9c1f4905916f05a5bb87bb6c4dac" id="r_a30df9c1f4905916f05a5bb87bb6c4dac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a30df9c1f4905916f05a5bb87bb6c4dac">GenerateGLLPoints</a> (const size_t order)</td></tr>
<tr class="memdesc:a30df9c1f4905916f05a5bb87bb6c4dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates Gauss-Lobatto-Legendre (GLL) points for spectral element discretization.  <br /></td></tr>
<tr class="separator:a30df9c1f4905916f05a5bb87bb6c4dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e504d583e397e7a36eed8b501e9885f" id="r_a0e504d583e397e7a36eed8b501e9885f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a0e504d583e397e7a36eed8b501e9885f">MapGeometricLocations</a> (std::span&lt; const double &gt; geom_locations)</td></tr>
<tr class="memdesc:a0e504d583e397e7a36eed8b501e9885f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps input geometric locations -&gt; normalized domain using linear mapping.  <br /></td></tr>
<tr class="separator:a0e504d583e397e7a36eed8b501e9885f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a70ffdb98137f7b8da14b1f9455236" id="r_ad3a70ffdb98137f7b8da14b1f9455236"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#ad3a70ffdb98137f7b8da14b1f9455236">ComputeShapeFunctionValues</a> (std::span&lt; const double &gt; input_points, std::span&lt; const double &gt; output_points)</td></tr>
<tr class="memdesc:ad3a70ffdb98137f7b8da14b1f9455236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes shape function matrices ϕg relating points ξb to ξg At least two input points are required and it is assumed that there are more output points than input points.  <br /></td></tr>
<tr class="separator:ad3a70ffdb98137f7b8da14b1f9455236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7f27e797612c16751b40e66523f33c" id="r_aeb7f27e797612c16751b40e66523f33c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#aeb7f27e797612c16751b40e66523f33c">ComputeShapeFunctionDerivatives</a> (std::span&lt; const double &gt; input_points, std::span&lt; const double &gt; output_points)</td></tr>
<tr class="memdesc:aeb7f27e797612c16751b40e66523f33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes shape function derivatives dϕg relating points ξb to ξg At least two input points are required and it is assumed that there are more output points than input points.  <br /></td></tr>
<tr class="separator:aeb7f27e797612c16751b40e66523f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab24abfc64d85df30632483da92982e" id="r_a8ab24abfc64d85df30632483da92982e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a8ab24abfc64d85df30632483da92982e">PerformLeastSquaresFitting</a> (size_t p, std::span&lt; const std::vector&lt; double &gt; &gt; shape_functions, std::span&lt; const std::array&lt; double, 3 &gt; &gt; points_to_fit)</td></tr>
<tr class="memdesc:a8ab24abfc64d85df30632483da92982e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs least squares fitting to determine interpolation coefficients.  <br /></td></tr>
<tr class="separator:a8ab24abfc64d85df30632483da92982e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1459d47d860f610931a8ede98a78e280" id="r_a1459d47d860f610931a8ede98a78e280"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a1459d47d860f610931a8ede98a78e280"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a1459d47d860f610931a8ede98a78e280">AX_Matrix</a> (const Matrix &amp;A, const Matrix &amp;AX_A)</td></tr>
<tr class="memdesc:a1459d47d860f610931a8ede98a78e280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes AX(A) of a square matrix.  <br /></td></tr>
<tr class="separator:a1459d47d860f610931a8ede98a78e280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf0e2026878c8edf141f7c4ad011119" id="r_afbf0e2026878c8edf141f7c4ad011119"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:afbf0e2026878c8edf141f7c4ad011119"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#afbf0e2026878c8edf141f7c4ad011119">AxialVectorOfMatrix</a> (const Matrix &amp;m, const Vector &amp;v)</td></tr>
<tr class="memdesc:afbf0e2026878c8edf141f7c4ad011119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the axial vector (also known as the vector representation) of a 3x3 skew-symmetric matrix.  <br /></td></tr>
<tr class="separator:afbf0e2026878c8edf141f7c4ad011119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9dd63cade74011b4b88114f84f97d2" id="r_a4d9dd63cade74011b4b88114f84f97d2"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a4d9dd63cade74011b4b88114f84f97d2">RotateMatrix6</a> (const std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; &amp;m, const std::array&lt; double, 4 &gt; &amp;q)</td></tr>
<tr class="separator:a4d9dd63cade74011b4b88114f84f97d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c8365ee4847555261a77b20dece933" id="r_a08c8365ee4847555261a77b20dece933"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a08c8365ee4847555261a77b20dece933">ProjectPointsToTargetPolynomial</a> (size_t num_inputs, size_t num_outputs, std::span&lt; const std::array&lt; double, 3 &gt; &gt; input_points)</td></tr>
<tr class="memdesc:a08c8365ee4847555261a77b20dece933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects 3D points from a given (lower) polynomial representation to a target (higher) polynomial representation.  <br /></td></tr>
<tr class="separator:a08c8365ee4847555261a77b20dece933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf373b0e69059a2cf9c9b4b15977aa7b" id="r_adf373b0e69059a2cf9c9b4b15977aa7b"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename RotationMatrix &gt; </td></tr>
<tr class="memitem:adf373b0e69059a2cf9c9b4b15977aa7b"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#adf373b0e69059a2cf9c9b4b15977aa7b">QuaternionToRotationMatrix</a> (const Quaternion &amp;q, const RotationMatrix &amp;R)</td></tr>
<tr class="memdesc:adf373b0e69059a2cf9c9b4b15977aa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result.  <br /></td></tr>
<tr class="separator:adf373b0e69059a2cf9c9b4b15977aa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7287ec3ae4409a3ce3130c90b6f8a58c" id="r_a7287ec3ae4409a3ce3130c90b6f8a58c"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a7287ec3ae4409a3ce3130c90b6f8a58c">QuaternionToRotationMatrix</a> (const std::array&lt; double, 4 &gt; &amp;q)</td></tr>
<tr class="memdesc:a7287ec3ae4409a3ce3130c90b6f8a58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result.  <br /></td></tr>
<tr class="separator:a7287ec3ae4409a3ce3130c90b6f8a58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfbc31bd5c1916e12111325d79bb947" id="r_a3cfbc31bd5c1916e12111325d79bb947"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a3cfbc31bd5c1916e12111325d79bb947">RotationMatrixToQuaternion</a> (const std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt; &amp;m)</td></tr>
<tr class="memdesc:a3cfbc31bd5c1916e12111325d79bb947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3x3 rotation matrix to a 4x1 quaternion and returns the result, see <a href="https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/">https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</a> for implementation details.  <br /></td></tr>
<tr class="separator:a3cfbc31bd5c1916e12111325d79bb947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa000e1f3373e87b8744b1552b83ad232" id="r_aa000e1f3373e87b8744b1552b83ad232"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename View1 , typename View2 &gt; </td></tr>
<tr class="memitem:aa000e1f3373e87b8744b1552b83ad232"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#aa000e1f3373e87b8744b1552b83ad232">RotateVectorByQuaternion</a> (const Quaternion &amp;q, const View1 &amp;v, const View2 &amp;v_rot)</td></tr>
<tr class="memdesc:aa000e1f3373e87b8744b1552b83ad232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates provided vector by provided <em>unit</em> quaternion and returns the result.  <br /></td></tr>
<tr class="separator:aa000e1f3373e87b8744b1552b83ad232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8cb68447e1c691d8adeb2a9f30c1a1" id="r_a9e8cb68447e1c691d8adeb2a9f30c1a1"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a9e8cb68447e1c691d8adeb2a9f30c1a1">RotateVectorByQuaternion</a> (std::span&lt; const double, 4 &gt; q, std::span&lt; const double, 3 &gt; v)</td></tr>
<tr class="memdesc:a9e8cb68447e1c691d8adeb2a9f30c1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates provided vector by provided <em>unit</em> quaternion and returns the result.  <br /></td></tr>
<tr class="separator:a9e8cb68447e1c691d8adeb2a9f30c1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69056e5ab2dff263866d8301e212b77" id="r_ae69056e5ab2dff263866d8301e212b77"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename Matrix &gt; </td></tr>
<tr class="memitem:ae69056e5ab2dff263866d8301e212b77"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#ae69056e5ab2dff263866d8301e212b77">QuaternionDerivative</a> (const Quaternion &amp;q, const Matrix &amp;m)</td></tr>
<tr class="memdesc:ae69056e5ab2dff263866d8301e212b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of a quaternion and stores the result in a 3x4 matrix.  <br /></td></tr>
<tr class="separator:ae69056e5ab2dff263866d8301e212b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87bcca912aeb86bd49db57abe613f14" id="r_af87bcca912aeb86bd49db57abe613f14"><td class="memTemplParams" colspan="2">template&lt;typename QuaternionInput , typename QuaternionOutput &gt; </td></tr>
<tr class="memitem:af87bcca912aeb86bd49db57abe613f14"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#af87bcca912aeb86bd49db57abe613f14">QuaternionInverse</a> (const QuaternionInput &amp;q_in, const QuaternionOutput &amp;q_out)</td></tr>
<tr class="memdesc:af87bcca912aeb86bd49db57abe613f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a quaternion.  <br /></td></tr>
<tr class="separator:af87bcca912aeb86bd49db57abe613f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc13c59521ea1e732fdbc637b4a7f2f" id="r_a0cc13c59521ea1e732fdbc637b4a7f2f"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a0cc13c59521ea1e732fdbc637b4a7f2f">QuaternionInverse</a> (std::span&lt; const double, 4 &gt; quaternion)</td></tr>
<tr class="memdesc:a0cc13c59521ea1e732fdbc637b4a7f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a quaternion.  <br /></td></tr>
<tr class="separator:a0cc13c59521ea1e732fdbc637b4a7f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee21a28df439eabcc9f3c5bacf27d70" id="r_a1ee21a28df439eabcc9f3c5bacf27d70"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion1 , typename Quaternion2 , typename QuaternionN &gt; </td></tr>
<tr class="memitem:a1ee21a28df439eabcc9f3c5bacf27d70"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a1ee21a28df439eabcc9f3c5bacf27d70">QuaternionCompose</a> (const Quaternion1 &amp;q1, const Quaternion2 &amp;q2, QuaternionN &amp;qn)</td></tr>
<tr class="memdesc:a1ee21a28df439eabcc9f3c5bacf27d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes (i.e. multiplies) two quaternions and stores the result in a third quaternion.  <br /></td></tr>
<tr class="separator:a1ee21a28df439eabcc9f3c5bacf27d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c851fd2350d6d04647a4a6cc4e86ae" id="r_a06c851fd2350d6d04647a4a6cc4e86ae"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a06c851fd2350d6d04647a4a6cc4e86ae">QuaternionCompose</a> (const std::array&lt; double, 4 &gt; &amp;q1, const std::array&lt; double, 4 &gt; &amp;q2)</td></tr>
<tr class="memdesc:a06c851fd2350d6d04647a4a6cc4e86ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes (i.e. multiplies) two quaternions and returns the result.  <br /></td></tr>
<tr class="separator:a06c851fd2350d6d04647a4a6cc4e86ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735a2c2c1e0b67cb7feab767c3f1c0bd" id="r_a735a2c2c1e0b67cb7feab767c3f1c0bd"><td class="memTemplParams" colspan="2">template&lt;typename Vector , typename Quaternion &gt; </td></tr>
<tr class="memitem:a735a2c2c1e0b67cb7feab767c3f1c0bd"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a735a2c2c1e0b67cb7feab767c3f1c0bd">RotationVectorToQuaternion</a> (const Vector &amp;phi, const Quaternion &amp;quaternion)</td></tr>
<tr class="memdesc:a735a2c2c1e0b67cb7feab767c3f1c0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map.  <br /></td></tr>
<tr class="separator:a735a2c2c1e0b67cb7feab767c3f1c0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d59782b98eb0421bc143aea3f00d1a" id="r_a06d59782b98eb0421bc143aea3f00d1a"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename Vector &gt; </td></tr>
<tr class="memitem:a06d59782b98eb0421bc143aea3f00d1a"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a06d59782b98eb0421bc143aea3f00d1a">QuaternionToRotationVector</a> (const Quaternion &amp;quaternion, const Vector &amp;phi)</td></tr>
<tr class="memdesc:a06d59782b98eb0421bc143aea3f00d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 3-D rotation vector from provided 4-D quaternion, i.e. the logarithmic map.  <br /></td></tr>
<tr class="separator:a06d59782b98eb0421bc143aea3f00d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a0ce44a4462dd3a42ce2b1c28f3c14" id="r_ac6a0ce44a4462dd3a42ce2b1c28f3c14"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#ac6a0ce44a4462dd3a42ce2b1c28f3c14">QuaternionToRotationVector</a> (const std::array&lt; double, 4 &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:ac6a0ce44a4462dd3a42ce2b1c28f3c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 3-D rotation vector from provided 4-D quaternion.  <br /></td></tr>
<tr class="separator:ac6a0ce44a4462dd3a42ce2b1c28f3c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f4d3a64e66434c86c9722122fea24e" id="r_ac5f4d3a64e66434c86c9722122fea24e"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#ac5f4d3a64e66434c86c9722122fea24e">RotationVectorToQuaternion</a> (const std::array&lt; double, 3 &gt; &amp;phi)</td></tr>
<tr class="memdesc:ac5f4d3a64e66434c86c9722122fea24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map.  <br /></td></tr>
<tr class="separator:ac5f4d3a64e66434c86c9722122fea24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5ea67b94098aeeadb3a0cb4bf345e1" id="r_a9b5ea67b94098aeeadb3a0cb4bf345e1"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION Kokkos::Array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a9b5ea67b94098aeeadb3a0cb4bf345e1">NormalizeQuaternion</a> (const Kokkos::Array&lt; double, 4 &gt; &amp;q)</td></tr>
<tr class="memdesc:a9b5ea67b94098aeeadb3a0cb4bf345e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a quaternion to ensure it is a unit quaternion.  <br /></td></tr>
<tr class="separator:a9b5ea67b94098aeeadb3a0cb4bf345e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1641bfc02c962ed37d49b043dc20f3be" id="r_a1641bfc02c962ed37d49b043dc20f3be"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a1641bfc02c962ed37d49b043dc20f3be">TangentTwistToQuaternion</a> (const std::array&lt; double, 3 &gt; &amp;tangent, const double twist)</td></tr>
<tr class="memdesc:a1641bfc02c962ed37d49b043dc20f3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4-D quaternion from provided tangent vector and twist (degrees) about tangent.  <br /></td></tr>
<tr class="separator:a1641bfc02c962ed37d49b043dc20f3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c68027e8253476d01f7ff4924caf9fe" id="r_a4c68027e8253476d01f7ff4924caf9fe"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a4c68027e8253476d01f7ff4924caf9fe">AxisAngleToQuaternion</a> (const std::array&lt; double, 3 &gt; &amp;axis, double angle)</td></tr>
<tr class="memdesc:a4c68027e8253476d01f7ff4924caf9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quaternion from the axis vector and angle (radians)  <br /></td></tr>
<tr class="separator:a4c68027e8253476d01f7ff4924caf9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990d8f612553ef53c1492a2821ca12fa" id="r_a990d8f612553ef53c1492a2821ca12fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a990d8f612553ef53c1492a2821ca12fa">IsIdentityQuaternion</a> (const std::array&lt; double, 4 &gt; &amp;q, double tolerance=1e-12)</td></tr>
<tr class="memdesc:a990d8f612553ef53c1492a2821ca12fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a quaternion is approximately the identity quaternion [1, 0, 0, 0].  <br /></td></tr>
<tr class="separator:a990d8f612553ef53c1492a2821ca12fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a43d6a9aaac7df2dd712b108156b62" id="r_a60a43d6a9aaac7df2dd712b108156b62"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename MatrixType &gt; </td></tr>
<tr class="memitem:a60a43d6a9aaac7df2dd712b108156b62"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a60a43d6a9aaac7df2dd712b108156b62">VecTilde</a> (const VectorType &amp;vector, const MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:a60a43d6a9aaac7df2dd712b108156b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3x1 vector to a 3x3 skew-symmetric matrix and returns the result.  <br /></td></tr>
<tr class="separator:a60a43d6a9aaac7df2dd712b108156b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d869cbb485659b560364301b6f84379" id="r_a8d869cbb485659b560364301b6f84379"><td class="memTemplParams" colspan="2">template&lt;typename AVectorType , typename BVectorType &gt; </td></tr>
<tr class="memitem:a8d869cbb485659b560364301b6f84379"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a8d869cbb485659b560364301b6f84379">DotProduct</a> (const AVectorType &amp;a, const BVectorType &amp;b)</td></tr>
<tr class="memdesc:a8d869cbb485659b560364301b6f84379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dot product between two vector views.  <br /></td></tr>
<tr class="separator:a8d869cbb485659b560364301b6f84379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea10e6ca7ef91b245f012755a3d9c5ee" id="r_aea10e6ca7ef91b245f012755a3d9c5ee"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#aea10e6ca7ef91b245f012755a3d9c5ee">DotProduct</a> (const std::array&lt; double, 3 &gt; &amp;a, const std::array&lt; double, 3 &gt; &amp;b)</td></tr>
<tr class="memdesc:aea10e6ca7ef91b245f012755a3d9c5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dot product between two vector views.  <br /></td></tr>
<tr class="separator:aea10e6ca7ef91b245f012755a3d9c5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1237209d5686aa38024e89425909e3f9" id="r_a1237209d5686aa38024e89425909e3f9"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a1237209d5686aa38024e89425909e3f9"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a1237209d5686aa38024e89425909e3f9">CrossProduct</a> (const VectorType &amp;a, const VectorType &amp;b, const VectorType &amp;c)</td></tr>
<tr class="memdesc:a1237209d5686aa38024e89425909e3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cross product between two vector views.  <br /></td></tr>
<tr class="separator:a1237209d5686aa38024e89425909e3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99792ad60aad06d8f1b5fd19f12802b4" id="r_a99792ad60aad06d8f1b5fd19f12802b4"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#a99792ad60aad06d8f1b5fd19f12802b4">CrossProduct</a> (std::span&lt; const double, 3 &gt; a, std::span&lt; const double, 3 &gt; b)</td></tr>
<tr class="memdesc:a99792ad60aad06d8f1b5fd19f12802b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cross product between two vectors.  <br /></td></tr>
<tr class="separator:a99792ad60aad06d8f1b5fd19f12802b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88b47af8a54430f9f529981dd5aee47" id="r_ab88b47af8a54430f9f529981dd5aee47"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#ab88b47af8a54430f9f529981dd5aee47">Norm</a> (const std::array&lt; double, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:ab88b47af8a54430f9f529981dd5aee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the norm of a given vector.  <br /></td></tr>
<tr class="separator:ab88b47af8a54430f9f529981dd5aee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92a2d56ed92c20ce8847c18a988af44" id="r_ad92a2d56ed92c20ce8847c18a988af44"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekynema_1_1math.html#ad92a2d56ed92c20ce8847c18a988af44">UnitVector</a> (const std::array&lt; double, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:ad92a2d56ed92c20ce8847c18a988af44"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnitVector returns the unit vector of the given vector.  <br /></td></tr>
<tr class="separator:ad92a2d56ed92c20ce8847c18a988af44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1459d47d860f610931a8ede98a78e280" name="a1459d47d860f610931a8ede98a78e280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1459d47d860f610931a8ede98a78e280">&#9670;&#160;</a></span>AX_Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::AX_Matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>AX_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes AX(A) of a square matrix. </p>
<p>AX(A) = tr(A)/2 * I - A/2, where I is the identity matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input square matrix </td></tr>
    <tr><td class="paramname">AX_A</td><td>Output matrix containing the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbf0e2026878c8edf141f7c4ad011119" name="afbf0e2026878c8edf141f7c4ad011119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf0e2026878c8edf141f7c4ad011119">&#9670;&#160;</a></span>AxialVectorOfMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::AxialVectorOfMatrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the axial vector (also known as the vector representation) of a 3x3 skew-symmetric matrix. </p>
<p>The axial vector is defined as [w₁, w₂, w₃]ᵀ where: w₁ = (m₃₂ - m₂₃)/2 w₂ = (m₁₃ - m₃₁)/2 w₃ = (m₂₁ - m₁₂)/2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Input 3x3 rotation matrix </td></tr>
    <tr><td class="paramname">v</td><td>Output vector to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Matrix m must be 3x3 and vector v must have size 3 </dd></dl>

</div>
</div>
<a id="a4c68027e8253476d01f7ff4924caf9fe" name="a4c68027e8253476d01f7ff4924caf9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c68027e8253476d01f7ff4924caf9fe">&#9670;&#160;</a></span>AxisAngleToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; kynema::math::AxisAngleToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a quaternion from the axis vector and angle (radians) </p>

</div>
</div>
<a id="aeb7f27e797612c16751b40e66523f33c" name="aeb7f27e797612c16751b40e66523f33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7f27e797612c16751b40e66523f33c">&#9670;&#160;</a></span>ComputeShapeFunctionDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; kynema::math::ComputeShapeFunctionDerivatives </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>input_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>output_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes shape function derivatives dϕg relating points ξb to ξg At least two input points are required and it is assumed that there are more output points than input points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_points</td><td>Input points, ξb, in [-1, 1] </td></tr>
    <tr><td class="paramname">output_points</td><td>Output points, ξg, in [-1, 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shape function derivative matrix </dd></dl>

</div>
</div>
<a id="ad3a70ffdb98137f7b8da14b1f9455236" name="ad3a70ffdb98137f7b8da14b1f9455236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a70ffdb98137f7b8da14b1f9455236">&#9670;&#160;</a></span>ComputeShapeFunctionValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; kynema::math::ComputeShapeFunctionValues </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>input_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>output_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes shape function matrices ϕg relating points ξb to ξg At least two input points are required and it is assumed that there are more output points than input points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_points</td><td>Input points, ξb, in [-1, 1] </td></tr>
    <tr><td class="paramname">output_points</td><td>Output points, ξg, in [-1, 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shape function matrix </dd></dl>

</div>
</div>
<a id="a1237209d5686aa38024e89425909e3f9" name="a1237209d5686aa38024e89425909e3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1237209d5686aa38024e89425909e3f9">&#9670;&#160;</a></span>CrossProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::CrossProduct </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cross product between two vector views. </p>

</div>
</div>
<a id="a99792ad60aad06d8f1b5fd19f12802b4" name="a99792ad60aad06d8f1b5fd19f12802b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99792ad60aad06d8f1b5fd19f12802b4">&#9670;&#160;</a></span>CrossProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; double, 3 &gt; kynema::math::CrossProduct </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const double, 3 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double, 3 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the cross product between two vectors. </p>

</div>
</div>
<a id="a8d869cbb485659b560364301b6f84379" name="a8d869cbb485659b560364301b6f84379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d869cbb485659b560364301b6f84379">&#9670;&#160;</a></span>DotProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AVectorType , typename BVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION double kynema::math::DotProduct </td>
          <td>(</td>
          <td class="paramtype">const AVectorType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the dot product between two vector views. </p>

</div>
</div>
<a id="aea10e6ca7ef91b245f012755a3d9c5ee" name="aea10e6ca7ef91b245f012755a3d9c5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea10e6ca7ef91b245f012755a3d9c5ee">&#9670;&#160;</a></span>DotProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double kynema::math::DotProduct </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dot product between two vector views. </p>

</div>
</div>
<a id="a30df9c1f4905916f05a5bb87bb6c4dac" name="a30df9c1f4905916f05a5bb87bb6c4dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30df9c1f4905916f05a5bb87bb6c4dac">&#9670;&#160;</a></span>GenerateGLLPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; kynema::math::GenerateGLLPoints </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates Gauss-Lobatto-Legendre (GLL) points for spectral element discretization. </p>
<p>Computes the GLL points, i.e. roots of the Legendre polynomial, using Newton-Raphson iteration. GLL points are optimal interpolation nodes for spectral methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Order of the polynomial interpolation (must be &gt;= 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of GLL points sorted in ascending order, size = order + 1 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if order &lt; 1 </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if Newton-Raphson iteration fails to converge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a990d8f612553ef53c1492a2821ca12fa" name="a990d8f612553ef53c1492a2821ca12fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990d8f612553ef53c1492a2821ca12fa">&#9670;&#160;</a></span>IsIdentityQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kynema::math::IsIdentityQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a quaternion is approximately the identity quaternion [1, 0, 0, 0]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion to check </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance for the comparison (default: 1e-12) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the quaternion is approximately the identity quaternion, false otherwise </dd></dl>

</div>
</div>
<a id="a55aa78460bdbb9616c64bb8837da1f2c" name="a55aa78460bdbb9616c64bb8837da1f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55aa78460bdbb9616c64bb8837da1f2c">&#9670;&#160;</a></span>LagrangePolynomialDerivWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kynema::math::LagrangePolynomialDerivWeights </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes weights for Lagrange polynomial derivative interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Interpolation nodes (sorted) </td></tr>
    <tr><td class="paramname">weights</td><td>Output: weights for Lagrange polynomial derivative interpolation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36dd71b3ba890b71a34198d3da48125a" name="a36dd71b3ba890b71a34198d3da48125a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dd71b3ba890b71a34198d3da48125a">&#9670;&#160;</a></span>LagrangePolynomialInterpWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kynema::math::LagrangePolynomialInterpWeights </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes weights for Lagrange polynomial interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Interpolation nodes (sorted) </td></tr>
    <tr><td class="paramname">weights</td><td>Output: weights for Lagrange polynomial interpolation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42f9db3bae76edd783981815a2c8b571" name="a42f9db3bae76edd783981815a2c8b571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f9db3bae76edd783981815a2c8b571">&#9670;&#160;</a></span>LegendrePolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double kynema::math::LegendrePolynomial </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the value of Legendre polynomial of order n at point x. </p>
<p>Uses the recurrence relation for Legendre polynomials: P_n(x) = ((2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x))/n Reference: Deville et al. (2002) "High-Order Methods for Incompressible Fluid Flow" DOI: <a href="https://doi.org/10.1017/CBO9780511546792">https://doi.org/10.1017/CBO9780511546792</a>, Eq. B.1.15, p.446</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Order of the Legendre polynomial (n &gt;= 0) </td></tr>
    <tr><td class="paramname">x</td><td>Point at which to evaluate the polynomial, typically in [-1,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the nth order Legendre polynomial at x </dd></dl>

</div>
</div>
<a id="af446ed12cbeafb698952c0dd51380a4e" name="af446ed12cbeafb698952c0dd51380a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af446ed12cbeafb698952c0dd51380a4e">&#9670;&#160;</a></span>LinearInterp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double kynema::math::LinearInterp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes linear interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Value locations </td></tr>
    <tr><td class="paramname">values</td><td>Values at given locations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated value at evaluation point </dd></dl>

</div>
</div>
<a id="a4c8b96ab1fcaa05338745026f25e883c" name="a4c8b96ab1fcaa05338745026f25e883c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8b96ab1fcaa05338745026f25e883c">&#9670;&#160;</a></span>LinearInterpWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kynema::math::LinearInterpWeights </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes weights for linear interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Interpolation nodes (sorted) </td></tr>
    <tr><td class="paramname">weights</td><td>Output: weights for linear interpolation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e504d583e397e7a36eed8b501e9885f" name="a0e504d583e397e7a36eed8b501e9885f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e504d583e397e7a36eed8b501e9885f">&#9670;&#160;</a></span>MapGeometricLocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; kynema::math::MapGeometricLocations </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const double &gt;&#160;</td>
          <td class="paramname"><em>geom_locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps input geometric locations -&gt; normalized domain using linear mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geom_locations</td><td>Input geometric locations (typically in domain [0, 1]), sorted in ascending order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; Mapped/normalized evaluation points in domain [-1, 1] </dd></dl>

</div>
</div>
<a id="ab88b47af8a54430f9f529981dd5aee47" name="ab88b47af8a54430f9f529981dd5aee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88b47af8a54430f9f529981dd5aee47">&#9670;&#160;</a></span>Norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double kynema::math::Norm </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the norm of a given vector. </p>

</div>
</div>
<a id="a9b5ea67b94098aeeadb3a0cb4bf345e1" name="a9b5ea67b94098aeeadb3a0cb4bf345e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5ea67b94098aeeadb3a0cb4bf345e1">&#9670;&#160;</a></span>NormalizeQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION Kokkos::Array&lt; double, 4 &gt; kynema::math::NormalizeQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a quaternion to ensure it is a unit quaternion. </p>
<p>If the length of the quaternion is zero, it returns a default unit quaternion. Otherwise, it normalizes the quaternion and returns the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The input quaternion as a Kokkos::Array&lt;double, 4&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kokkos::Array&lt;double, 4&gt; The normalized quaternion </dd></dl>

</div>
</div>
<a id="a8ab24abfc64d85df30632483da92982e" name="a8ab24abfc64d85df30632483da92982e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab24abfc64d85df30632483da92982e">&#9670;&#160;</a></span>PerformLeastSquaresFitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; double, 3 &gt; &gt; kynema::math::PerformLeastSquaresFitting </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>shape_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::array&lt; double, 3 &gt; &gt;&#160;</td>
          <td class="paramname"><em>points_to_fit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs least squares fitting to determine interpolation coefficients. </p>
<p>Performs least squares fitting to determine interpolation coefficients by solving a dense linear system [A][X] = [B], where [A] is the shape function matrix (p x n), [B] is the input points (n x 3), and [X] is the interpolation coefficients (p x 3)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Number of points representing the polynomial of order p-1 </td></tr>
    <tr><td class="paramname">shape_functions</td><td>Shape function matrix (p x n) </td></tr>
    <tr><td class="paramname">points_to_fit</td><td>x,y,z coordinates of the points to fit (n x 3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation coefficients (p x 3) </dd></dl>

</div>
</div>
<a id="a08c8365ee4847555261a77b20dece933" name="a08c8365ee4847555261a77b20dece933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c8365ee4847555261a77b20dece933">&#9670;&#160;</a></span>ProjectPointsToTargetPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; double, 3 &gt; &gt; kynema::math::ProjectPointsToTargetPolynomial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const std::array&lt; double, 3 &gt; &gt;&#160;</td>
          <td class="paramname"><em>input_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects 3D points from a given (lower) polynomial representation to a target (higher) polynomial representation. </p>
<p>This function maps a set of 3D points defined at nodes of a polynomial of order source_order to corresponding points at nodes of a polynomial of order target_order (typically higher than the source order) using Least-Squares Finite Element (LSFE) shape functions.</p>
<p>Primary use case: The primary application of this function is to increase the number of points from a lower-order geometric representation to the higher-order representation required for spectral finite element analysis. This enables the use of high-order methods while allowing geometry to be defined with fewer points initially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_inputs</td><td>Number of points in the source polynomial representation </td></tr>
    <tr><td class="paramname">num_outputs</td><td>Number of points in the target polynomial representation </td></tr>
    <tr><td class="paramname">input_points</td><td>3D coordinates of points in the source representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::array&lt;double, 3&gt;&gt;<ul>
<li>Coordinates of the projected 3D points at the target polynomial nodes </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1ee21a28df439eabcc9f3c5bacf27d70" name="a1ee21a28df439eabcc9f3c5bacf27d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee21a28df439eabcc9f3c5bacf27d70">&#9670;&#160;</a></span>QuaternionCompose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion1 , typename Quaternion2 , typename QuaternionN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::QuaternionCompose </td>
          <td>(</td>
          <td class="paramtype">const Quaternion1 &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Quaternion2 &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QuaternionN &amp;&#160;</td>
          <td class="paramname"><em>qn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes (i.e. multiplies) two quaternions and stores the result in a third quaternion. </p>

</div>
</div>
<a id="a06c851fd2350d6d04647a4a6cc4e86ae" name="a06c851fd2350d6d04647a4a6cc4e86ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c851fd2350d6d04647a4a6cc4e86ae">&#9670;&#160;</a></span>QuaternionCompose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; kynema::math::QuaternionCompose </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes (i.e. multiplies) two quaternions and returns the result. </p>

</div>
</div>
<a id="ae69056e5ab2dff263866d8301e212b77" name="ae69056e5ab2dff263866d8301e212b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69056e5ab2dff263866d8301e212b77">&#9670;&#160;</a></span>QuaternionDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::QuaternionDerivative </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of a quaternion and stores the result in a 3x4 matrix. </p>

</div>
</div>
<a id="af87bcca912aeb86bd49db57abe613f14" name="af87bcca912aeb86bd49db57abe613f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87bcca912aeb86bd49db57abe613f14">&#9670;&#160;</a></span>QuaternionInverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename QuaternionInput , typename QuaternionOutput &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::QuaternionInverse </td>
          <td>(</td>
          <td class="paramtype">const QuaternionInput &amp;&#160;</td>
          <td class="paramname"><em>q_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuaternionOutput &amp;&#160;</td>
          <td class="paramname"><em>q_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of a quaternion. </p>

</div>
</div>
<a id="a0cc13c59521ea1e732fdbc637b4a7f2f" name="a0cc13c59521ea1e732fdbc637b4a7f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc13c59521ea1e732fdbc637b4a7f2f">&#9670;&#160;</a></span>QuaternionInverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; kynema::math::QuaternionInverse </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const double, 4 &gt;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse of a quaternion. </p>

</div>
</div>
<a id="adf373b0e69059a2cf9c9b4b15977aa7b" name="adf373b0e69059a2cf9c9b4b15977aa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf373b0e69059a2cf9c9b4b15977aa7b">&#9670;&#160;</a></span>QuaternionToRotationMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename RotationMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::QuaternionToRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RotationMatrix &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result. </p>

</div>
</div>
<a id="a7287ec3ae4409a3ce3130c90b6f8a58c" name="a7287ec3ae4409a3ce3130c90b6f8a58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7287ec3ae4409a3ce3130c90b6f8a58c">&#9670;&#160;</a></span>QuaternionToRotationMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt; kynema::math::QuaternionToRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result. </p>

</div>
</div>
<a id="a06d59782b98eb0421bc143aea3f00d1a" name="a06d59782b98eb0421bc143aea3f00d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d59782b98eb0421bc143aea3f00d1a">&#9670;&#160;</a></span>QuaternionToRotationVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::QuaternionToRotationVector </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 3-D rotation vector from provided 4-D quaternion, i.e. the logarithmic map. </p>

</div>
</div>
<a id="ac6a0ce44a4462dd3a42ce2b1c28f3c14" name="ac6a0ce44a4462dd3a42ce2b1c28f3c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a0ce44a4462dd3a42ce2b1c28f3c14">&#9670;&#160;</a></span>QuaternionToRotationVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; kynema::math::QuaternionToRotationVector </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 3-D rotation vector from provided 4-D quaternion. </p>

</div>
</div>
<a id="a4d9dd63cade74011b4b88114f84f97d2" name="a4d9dd63cade74011b4b88114f84f97d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9dd63cade74011b4b88114f84f97d2">&#9670;&#160;</a></span>RotateMatrix6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; kynema::math::RotateMatrix6 </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa000e1f3373e87b8744b1552b83ad232" name="aa000e1f3373e87b8744b1552b83ad232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa000e1f3373e87b8744b1552b83ad232">&#9670;&#160;</a></span>RotateVectorByQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename View1 , typename View2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::RotateVectorByQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const View1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const View2 &amp;&#160;</td>
          <td class="paramname"><em>v_rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates provided vector by provided <em>unit</em> quaternion and returns the result. </p>

</div>
</div>
<a id="a9e8cb68447e1c691d8adeb2a9f30c1a1" name="a9e8cb68447e1c691d8adeb2a9f30c1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8cb68447e1c691d8adeb2a9f30c1a1">&#9670;&#160;</a></span>RotateVectorByQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; kynema::math::RotateVectorByQuaternion </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const double, 4 &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const double, 3 &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates provided vector by provided <em>unit</em> quaternion and returns the result. </p>

</div>
</div>
<a id="a3cfbc31bd5c1916e12111325d79bb947" name="a3cfbc31bd5c1916e12111325d79bb947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfbc31bd5c1916e12111325d79bb947">&#9670;&#160;</a></span>RotationMatrixToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; kynema::math::RotationMatrixToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 3x3 rotation matrix to a 4x1 quaternion and returns the result, see <a href="https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/">https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</a> for implementation details. </p>

</div>
</div>
<a id="ac5f4d3a64e66434c86c9722122fea24e" name="ac5f4d3a64e66434c86c9722122fea24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f4d3a64e66434c86c9722122fea24e">&#9670;&#160;</a></span>RotationVectorToQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; kynema::math::RotationVectorToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map. </p>

</div>
</div>
<a id="a735a2c2c1e0b67cb7feab767c3f1c0bd" name="a735a2c2c1e0b67cb7feab767c3f1c0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735a2c2c1e0b67cb7feab767c3f1c0bd">&#9670;&#160;</a></span>RotationVectorToQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , typename Quaternion &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::RotationVectorToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map. </p>

</div>
</div>
<a id="a1641bfc02c962ed37d49b043dc20f3be" name="a1641bfc02c962ed37d49b043dc20f3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1641bfc02c962ed37d49b043dc20f3be">&#9670;&#160;</a></span>TangentTwistToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; kynema::math::TangentTwistToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 4-D quaternion from provided tangent vector and twist (degrees) about tangent. </p>

</div>
</div>
<a id="ad92a2d56ed92c20ce8847c18a988af44" name="ad92a2d56ed92c20ce8847c18a988af44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92a2d56ed92c20ce8847c18a988af44">&#9670;&#160;</a></span>UnitVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; double, 3 &gt; kynema::math::UnitVector </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UnitVector returns the unit vector of the given vector. </p>

</div>
</div>
<a id="a60a43d6a9aaac7df2dd712b108156b62" name="a60a43d6a9aaac7df2dd712b108156b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a43d6a9aaac7df2dd712b108156b62">&#9670;&#160;</a></span>VecTilde()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void kynema::math::VecTilde </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 3x1 vector to a 3x3 skew-symmetric matrix and returns the result. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 - Present, MIT License.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>