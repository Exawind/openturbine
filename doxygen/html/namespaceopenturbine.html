<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OpenTurbine API: openturbine Namespace Reference &mdash; OpenTurbine 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            OpenTurbine
              <img src="../../_static/oturb_logo_v2.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../user/user.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theory/index.html">Theory Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Developer Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgement.html">Acknowledgements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">OpenTurbine</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">OpenTurbine API: openturbine Namespace Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/doxygen/html/namespaceopenturbine.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="openturbine-namespace-reference">
<h1>openturbine Namespace Reference<a class="headerlink" href="#openturbine-namespace-reference" title="Permalink to this heading">ÔÉÅ</a></h1>
<div class="doxygen-content docutils container">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenTurbine API: openturbine Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenTurbine API
   </div>
   <div id="projectbrief">A flexible multibody structural dynamics code for wind turbines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">openturbine Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenturbine_1_1beams" id="r_namespaceopenturbine_1_1beams"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine_1_1beams.html">beams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenturbine_1_1cfd" id="r_namespaceopenturbine_1_1cfd"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine_1_1cfd.html">cfd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenturbine_1_1interfaces" id="r_namespaceopenturbine_1_1interfaces"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine_1_1interfaces.html">interfaces</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenturbine_1_1masses" id="r_namespaceopenturbine_1_1masses"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine_1_1masses.html">masses</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenturbine_1_1springs" id="r_namespaceopenturbine_1_1springs"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine_1_1springs.html">springs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenturbine_1_1util" id="r_namespaceopenturbine_1_1util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1AssembleNodeFreedomMapTable__Beams.html">AssembleNodeFreedomMapTable_Beams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1AssembleNodeFreedomMapTable__Constraints.html">AssembleNodeFreedomMapTable_Constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1AssembleNodeFreedomMapTable__Masses.html">AssembleNodeFreedomMapTable_Masses</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1AssembleNodeFreedomMapTable__Springs.html">AssembleNodeFreedomMapTable_Springs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beam element constitutes flexible beams material behavior in openturbine.  <a href="structopenturbine_1_1BeamElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Beams.html">Beams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the field variables needed to compute the per-element contributions to the residual vector and system matrix.  <a href="structopenturbine_1_1Beams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1BeamSection.html">BeamSection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1BeamsInput.html">BeamsInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the input data for creating flexible beams.  <a href="structopenturbine_1_1BeamsInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateConstraintOutput.html">CalculateConstraintOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateConstraintResidualGradient.html">CalculateConstraintResidualGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateConstraintsErrorSumSquares.html">CalculateConstraintsErrorSumSquares</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateDisplacement.html">CalculateDisplacement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateFixedBC3DOFConstraint.html">CalculateFixedBC3DOFConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateFixedBCConstraint.html">CalculateFixedBCConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateJacobian.html">CalculateJacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to calculate Jacobians and unit tangent vectors at quadrature points for beam elements.  <a href="structopenturbine_1_1CalculateJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateNextState.html">CalculateNextState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculatePrescribedBC3DOFConstraint.html">CalculatePrescribedBC3DOFConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculatePrescribedBCConstraint.html">CalculatePrescribedBCConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateQPPosition.html">CalculateQPPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to calculate current position and orientation at quadrature points.  <a href="structopenturbine_1_1CalculateQPPosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateRevoluteJointConstraint.html">CalculateRevoluteJointConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateRevoluteJointForce.html">CalculateRevoluteJointForce</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateRevoluteJointOutput.html">CalculateRevoluteJointOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateRigidJoint3DOFConstraint.html">CalculateRigidJoint3DOFConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateRigidJointConstraint.html">CalculateRigidJointConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateRotationControlConstraint.html">CalculateRotationControlConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateSystemErrorSumSquares.html">CalculateSystemErrorSumSquares</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CalculateTangentOperator.html">CalculateTangentOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeColInds.html">ComputeColInds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeConstraintsColInds.html">ComputeConstraintsColInds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeConstraintsRowEntries.html">ComputeConstraintsRowEntries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeNodeFreedomMapTable.html">ComputeNodeFreedomMapTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeNumSystemDofsReducer.html">ComputeNumSystemDofsReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeRowPtrs.html">ComputeRowPtrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeSystemColInds.html">ComputeSystemColInds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ComputeSystemRowEntries.html">ComputeSystemRowEntries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ConditionR.html">ConditionR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a constraint between two nodes or enforces a boundary condition at a single node.  <a href="structopenturbine_1_1Constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container class for managing multiple constraints in a simulation.  <a href="structopenturbine_1_1Constraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeBeamsToSparseMatrix.html">ContributeBeamsToSparseMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeBeamsToVector.html">ContributeBeamsToVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeConstraintsSystemResidualToVector.html">ContributeConstraintsSystemResidualToVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeForcesToVector.html">ContributeForcesToVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeLambdaToVector.html">ContributeLambdaToVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeMassesToSparseMatrix.html">ContributeMassesToSparseMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeMassesToVector.html">ContributeMassesToVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeSpringsToSparseMatrix.html">ContributeSpringsToSparseMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ContributeSpringsToVector.html">ContributeSpringsToVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CopyConstraintsResidualToVector.html">CopyConstraintsResidualToVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CopyConstraintsToSparseMatrix.html">CopyConstraintsToSparseMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CopyConstraintsTransposeToSparseMatrix.html">CopyConstraintsTransposeToSparseMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CreateConstraintFreedomTable.html">CreateConstraintFreedomTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CreateElementFreedomTable__Beams.html">CreateElementFreedomTable_Beams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CreateElementFreedomTable__Masses.html">CreateElementFreedomTable_Masses</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CreateElementFreedomTable__Springs.html">CreateElementFreedomTable_Springs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1CreateFullMatrix.html">CreateFullMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle.html">DSSHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle_3_01DSSAlgorithm_1_1CUDSS_01_4.html">DSSHandle&lt; DSSAlgorithm::CUDSS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle_3_01DSSAlgorithm_1_1CUSOLVER__SP_01_4.html">DSSHandle&lt; DSSAlgorithm::CUSOLVER_SP &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle_3_01DSSAlgorithm_1_1KLU_01_4.html">DSSHandle&lt; DSSAlgorithm::KLU &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle_3_01DSSAlgorithm_1_1MKL_01_4.html">DSSHandle&lt; DSSAlgorithm::MKL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle_3_01DSSAlgorithm_1_1SUPERLU_01_4.html">DSSHandle&lt; DSSAlgorithm::SUPERLU &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle_3_01DSSAlgorithm_1_1SUPERLU__MT_01_4.html">DSSHandle&lt; DSSAlgorithm::SUPERLU_MT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1DSSHandle_3_01DSSAlgorithm_1_1UMFPACK_01_4.html">DSSHandle&lt; DSSAlgorithm::UMFPACK &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction.html">DSSNumericFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1CUDSS_01_4_00_01CrsMatrixType_01_4.html">DSSNumericFunction&lt; DSSHandle&lt; DSSAlgorithm::CUDSS &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1CUSOLVER__SP_01_4_00_01CrsMatrixType_01_4.html">DSSNumericFunction&lt; DSSHandle&lt; DSSAlgorithm::CUSOLVER_SP &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1KLU_01_4_00_01CrsMatrixType_01_4.html">DSSNumericFunction&lt; DSSHandle&lt; DSSAlgorithm::KLU &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1MKL_01_4_00_01CrsMatrixType_01_4.html">DSSNumericFunction&lt; DSSHandle&lt; DSSAlgorithm::MKL &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1SUPERLU_01_4_00_01CrsMatrixType_01_4.html">DSSNumericFunction&lt; DSSHandle&lt; DSSAlgorithm::SUPERLU &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1SUPERLU__MT_01_4_00_01CrsMatrixType_01_4.html">DSSNumericFunction&lt; DSSHandle&lt; DSSAlgorithm::SUPERLU_MT &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSNumericFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1UMFPACK_01_4_00_01CrsMatrixType_01_4.html">DSSNumericFunction&lt; DSSHandle&lt; DSSAlgorithm::UMFPACK &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction.html">DSSSolveFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1CUDSS_01_4_00_01CrsMatrixType_00_01MultiVectorType_01_4.html">DSSSolveFunction&lt; DSSHandle&lt; DSSAlgorithm::CUDSS &gt;, CrsMatrixType, MultiVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1CUSOLVER__SP_01_4_00_01C4d8d35702731d112dc64d4ffca170209.html">DSSSolveFunction&lt; DSSHandle&lt; DSSAlgorithm::CUSOLVER_SP &gt;, CrsMatrixType, MultiVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1KLU_01_4_00_01CrsMatrixType_00_01MultiVectorType_01_4.html">DSSSolveFunction&lt; DSSHandle&lt; DSSAlgorithm::KLU &gt;, CrsMatrixType, MultiVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1MKL_01_4_00_01CrsMatrixType_00_01MultiVectorType_01_4.html">DSSSolveFunction&lt; DSSHandle&lt; DSSAlgorithm::MKL &gt;, CrsMatrixType, MultiVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1SUPERLU_01_4_00_01CrsMatf588915f69314d1242298debdc0a8168.html">DSSSolveFunction&lt; DSSHandle&lt; DSSAlgorithm::SUPERLU &gt;, CrsMatrixType, MultiVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1SUPERLU__MT_01_4_00_01Cr3b13f958259fe699d22226b2ff982cb1.html">DSSSolveFunction&lt; DSSHandle&lt; DSSAlgorithm::SUPERLU_MT &gt;, CrsMatrixType, MultiVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSolveFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1UMFPACK_01_4_00_01CrsMat839ec8a545dca7b68eca7413a19fb28c.html">DSSSolveFunction&lt; DSSHandle&lt; DSSAlgorithm::UMFPACK &gt;, CrsMatrixType, MultiVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction.html">DSSSymbolicFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1CUDSS_01_4_00_01CrsMatrixType_01_4.html">DSSSymbolicFunction&lt; DSSHandle&lt; DSSAlgorithm::CUDSS &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1CUSOLVER__SP_01_4_00_01CrsMatrixType_01_4.html">DSSSymbolicFunction&lt; DSSHandle&lt; DSSAlgorithm::CUSOLVER_SP &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1KLU_01_4_00_01CrsMatrixType_01_4.html">DSSSymbolicFunction&lt; DSSHandle&lt; DSSAlgorithm::KLU &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1MKL_01_4_00_01CrsMatrixType_01_4.html">DSSSymbolicFunction&lt; DSSHandle&lt; DSSAlgorithm::MKL &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1SUPERLU_01_4_00_01CrsMatrixType_01_4.html">DSSSymbolicFunction&lt; DSSHandle&lt; DSSAlgorithm::SUPERLU &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1SUPERLU__MT_01_4_00_01CrsMatrixType_01_4.html">DSSSymbolicFunction&lt; DSSHandle&lt; DSSAlgorithm::SUPERLU_MT &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1DSSSymbolicFunction_3_01DSSHandle_3_01DSSAlgorithm_1_1UMFPACK_01_4_00_01CrsMatrixType_01_4.html">DSSSymbolicFunction&lt; DSSHandle&lt; DSSAlgorithm::UMFPACK &gt;, CrsMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Elements.html">Elements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container providing handle to all structural elements present in the model.  <a href="structopenturbine_1_1Elements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1HollowCircleProperties.html">HollowCircleProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing geometric properties for a hollow circular cross-section.  <a href="structopenturbine_1_1HollowCircleProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateQPPosition.html">InterpolateQPPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates quadrature point positions from nodal positions using shape functions.  <a href="structopenturbine_1_1InterpolateQPPosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateQPRotation.html">InterpolateQPRotation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateQPState__r.html">InterpolateQPState_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the rotation (r) part of the state at a quadrature point.  <a href="structopenturbine_1_1InterpolateQPState__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateQPState__rprime.html">InterpolateQPState_rprime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the rotation derivative (r') part of the state at a quadrature point.  <a href="structopenturbine_1_1InterpolateQPState__rprime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateQPState__u.html">InterpolateQPState_u</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the displacement (u) part of the state at a quadrature point.  <a href="structopenturbine_1_1InterpolateQPState__u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateQPState__uprime.html">InterpolateQPState_uprime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the displacement derivative (u') part of the state at a quadrature point.  <a href="structopenturbine_1_1InterpolateQPState__uprime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateQPVector.html">InterpolateQPVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1InterpolateToQuadraturePoints.html">InterpolateToQuadraturePoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates various quantities from nodes to quadrature points for beam elements.  <a href="structopenturbine_1_1InterpolateToQuadraturePoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1MassElement.html">MassElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mass element constitutes rigid bodies/masses material behavior in openturbine. It has a single node and a single section completely defined by a 6x6 mass matrix.  <a href="structopenturbine_1_1MassElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Masses.html">Masses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains field variables for mass elements (aka, rigid bodies) to compute per-element contributions to the residual vector and system/iteration matrix.  <a href="structopenturbine_1_1Masses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1MassesInput.html">MassesInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the input data for creating mass/rigid body elements.  <a href="structopenturbine_1_1MassesInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1MeshConnectivity.html">MeshConnectivity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to manage element-to-node connectivity information for a mesh.  <a href="classopenturbine_1_1MeshConnectivity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1Model.html">Model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to define a turbine model with nodes, elements, and constraints.  <a href="classopenturbine_1_1Model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenturbine_1_1NodeBuilder.html">NodeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for constructing and configuring <a class="el" href="structopenturbine_1_1Node.html">Node</a> objects.  <a href="classopenturbine_1_1NodeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1ScanRowEntries.html">ScanRowEntries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object manages the assembly and solution of linear system arising from the generalized-alpha based time integration of the dynamic structural problem.  <a href="structopenturbine_1_1Solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1SpringElement.html">SpringElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spring element represents a constitutively linear spring connecting two nodes and defined by its scalar stiffness and undeformed length.  <a href="structopenturbine_1_1SpringElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1Springs.html">Springs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains field variables for spring elements to compute per-element contributions to the residual vector and system/iteration matrix.  <a href="structopenturbine_1_1Springs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1SpringsInput.html">SpringsInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the input data for creating spring elements.  <a href="structopenturbine_1_1SpringsInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1State.html">State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1UnconditionSolution.html">UnconditionSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1UpdateAlgorithmicAcceleration.html">UpdateAlgorithmicAcceleration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1UpdateDynamicPrediction.html">UpdateDynamicPrediction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1UpdateGlobalPosition.html">UpdateGlobalPosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1UpdateLambdaPrediction.html">UpdateLambdaPrediction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenturbine_1_1UpdateStaticPrediction.html">UpdateStaticPrediction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a86a41c4e6ed003fa419c858b8e6cd18d" id="r_a86a41c4e6ed003fa419c858b8e6cd18d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">ConstraintType</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18da6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18da0675be2979017444f65694563143ae05">FixedBC</a> = 1
, <a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18da301672e51ad71b8b62f2342e1ed4dd06">PrescribedBC</a> = 2
, <a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18da370a21b7043ed95e6a3edd1148e878af">RigidJoint</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18dadc7372c64ce46f9a406934dea0893143">RevoluteJoint</a> = 4
, <a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18dadfe188d9ca50087680a8c110cc826057">RotationControl</a> = 5
, <a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18da9874b01bdcca61f405b152e78344d098">FixedBC3DOFs</a> = 6
, <a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18da1a186c7997146fe73e33c92f2559b1e1">PrescribedBC3DOFs</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18dabfcb760f80357f56afc456eed1ea27f3">RigidJoint6DOFsTo3DOFs</a> = 8
<br />
 }</td></tr>
<tr class="separator:a86a41c4e6ed003fa419c858b8e6cd18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a0c4b14f459d6be7082dd819d5e15c" id="r_ac4a0c4b14f459d6be7082dd819d5e15c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a> : std::uint8_t { <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15ca3b833b799f6bc70091f2d9cf4e10f41e">AllComponents</a> = 0b00111111
, <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15cac3f1ed4c290648ed6b685b415448430d">JustPosition</a> = 0b00111000
, <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15ca6bd15481aa8778fbfe716b3aee6fa8be">JustRotation</a> = 0b00000111
, <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15cad777bc3d604905978e7e68786d91dd67">NoComponents</a> = 0b00000000
 }</td></tr>
<tr class="memdesc:ac4a0c4b14f459d6be7082dd819d5e15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the active degrees of freedom for a node.  <a href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">More...</a><br /></td></tr>
<tr class="separator:ac4a0c4b14f459d6be7082dd819d5e15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b08ab0fe95ca731068f06eae062b5b" id="r_ac0b08ab0fe95ca731068f06eae062b5b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5b">DSSAlgorithm</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5bae58d2e3a739d6b1f6bdd0daff2288ece">CUSOLVER_SP</a>
, <a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5ba3283f7ef1b1d9ecc3d65af213a0a8338">CUDSS</a>
, <a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5bad4dcdada1c05a280bb7e95da2874fa97">KLU</a>
, <a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5bad2a602ed8582b78e22141784e4a86165">UMFPACK</a>
, <br />
&#160;&#160;<a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5bae85f79ff3d82385beca51faebc04ab92">SUPERLU</a>
, <a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5ba2b5fb6f9206e24cb33edd6cf64195c31">SUPERLU_MT</a>
, <a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5ba6a8f79dd53a94059a5cdcd066199a06f">MKL</a>
, <a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5bab50339a10e1de285ac99d4c3990b8693">NONE</a>
<br />
 }</td></tr>
<tr class="separator:ac0b08ab0fe95ca731068f06eae062b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a382b442cac8b0bcc950d5b66d3268f53" id="r_a382b442cac8b0bcc950d5b66d3268f53"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a382b442cac8b0bcc950d5b66d3268f53">GetNumberOfNodes</a> (<a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">ConstraintType</a> t)</td></tr>
<tr class="memdesc:a382b442cac8b0bcc950d5b66d3268f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes used/required by the constraint type.  <br /></td></tr>
<tr class="separator:a382b442cac8b0bcc950d5b66d3268f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485ef13a60949d64665469a7fa2cf644" id="r_a485ef13a60949d64665469a7fa2cf644"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a485ef13a60949d64665469a7fa2cf644">NumColsForConstraint</a> (<a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">ConstraintType</a> type)</td></tr>
<tr class="memdesc:a485ef13a60949d64665469a7fa2cf644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of degrees of freedom prescribed/fixed by the constraint type.  <br /></td></tr>
<tr class="separator:a485ef13a60949d64665469a7fa2cf644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ddfd0e99cc8dfae2c642df6d8b1063" id="r_a14ddfd0e99cc8dfae2c642df6d8b1063"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a14ddfd0e99cc8dfae2c642df6d8b1063">NumRowsForConstraint</a> (<a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">ConstraintType</a> type)</td></tr>
<tr class="memdesc:a14ddfd0e99cc8dfae2c642df6d8b1063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of degrees of freedom prescribed/fixed by the constraint type.  <br /></td></tr>
<tr class="separator:a14ddfd0e99cc8dfae2c642df6d8b1063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932a665948376539c8aa98265a8e8257" id="r_a932a665948376539c8aa98265a8e8257"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a932a665948376539c8aa98265a8e8257"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a932a665948376539c8aa98265a8e8257">assemble_node_freedom_allocation_table</a> (<a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state, const <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;elements, const <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="separator:a932a665948376539c8aa98265a8e8257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab306821727cde73c9c0a552c66b62238" id="r_ab306821727cde73c9c0a552c66b62238"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:ab306821727cde73c9c0a552c66b62238"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ab306821727cde73c9c0a552c66b62238">compute_node_freedom_map_table</a> (<a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:ab306821727cde73c9c0a552c66b62238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54288e8047ccc914721bc897928e61cc" id="r_a54288e8047ccc914721bc897928e61cc"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a54288e8047ccc914721bc897928e61cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a54288e8047ccc914721bc897928e61cc">create_constraint_freedom_table</a> (<a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints, const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:a54288e8047ccc914721bc897928e61cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e93c3fd69a7f4617f67df3a8ece264" id="r_a68e93c3fd69a7f4617f67df3a8ece264"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a68e93c3fd69a7f4617f67df3a8ece264"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a68e93c3fd69a7f4617f67df3a8ece264">create_element_freedom_table</a> (<a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;elements, const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:a68e93c3fd69a7f4617f67df3a8ece264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c42f508c32ce963cde7215e5acd063" id="r_a46c42f508c32ce963cde7215e5acd063"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a46c42f508c32ce963cde7215e5acd063">operator|</a> (<a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a> x, <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a> y)</td></tr>
<tr class="memdesc:a46c42f508c32ce963cde7215e5acd063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two freedom signatures using bitwise OR.  <br /></td></tr>
<tr class="separator:a46c42f508c32ce963cde7215e5acd063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49461f4e15c88f90f8383dffa5ac51b" id="r_ac49461f4e15c88f90f8383dffa5ac51b"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac49461f4e15c88f90f8383dffa5ac51b">count_active_dofs</a> (<a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a> x)</td></tr>
<tr class="memdesc:ac49461f4e15c88f90f8383dffa5ac51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of active degrees of freedom in a signature.  <br /></td></tr>
<tr class="separator:ac49461f4e15c88f90f8383dffa5ac51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828012f9e18e6714c1f9ca3ba44d9e5f" id="r_a828012f9e18e6714c1f9ca3ba44d9e5f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a828012f9e18e6714c1f9ca3ba44d9e5f">CreateTrapezoidalQuadrature</a> (const std::vector&lt; double &gt; &amp;grid)</td></tr>
<tr class="separator:a828012f9e18e6714c1f9ca3ba44d9e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af984b601608050be09485b044eb900a7" id="r_af984b601608050be09485b044eb900a7"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:af984b601608050be09485b044eb900a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenturbine_1_1Beams.html">Beams</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#af984b601608050be09485b044eb900a7">CreateBeams</a> (const <a class="el" href="structopenturbine_1_1BeamsInput.html">BeamsInput</a> &amp;beams_input, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:af984b601608050be09485b044eb900a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8826904598850172d0f547e9ec05c38" id="r_ac8826904598850172d0f547e9ec05c38"><td class="memItemLeft" align="right" valign="top">static std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac8826904598850172d0f547e9ec05c38">GenerateStiffnessMatrix</a> (double EA, double EI_x, double EI_y, double GKt, double GA, double kxs, double kys, double x_C, double y_C, double theta_p, double x_S, double y_S, double theta_s)</td></tr>
<tr class="memdesc:ac8826904598850172d0f547e9ec05c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 6x6 cross-sectional stiffness matrix for use in beam elements.  <br /></td></tr>
<tr class="separator:ac8826904598850172d0f547e9ec05c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c12adbb0f9038c2bdd440d524ea57f6" id="r_a2c12adbb0f9038c2bdd440d524ea57f6"><td class="memItemLeft" align="right" valign="top">static std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a2c12adbb0f9038c2bdd440d524ea57f6">GenerateMassMatrix</a> (double m, double I_x, double I_y, double I_p, double x_G=0., double y_G=0., double theta_i=0.)</td></tr>
<tr class="memdesc:a2c12adbb0f9038c2bdd440d524ea57f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 6x6 cross-sectional mass matrix for use in beam elements.  <br /></td></tr>
<tr class="separator:a2c12adbb0f9038c2bdd440d524ea57f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b0000c5534a6d45904580d6de55850" id="r_a01b0000c5534a6d45904580d6de55850"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structopenturbine_1_1HollowCircleProperties.html">HollowCircleProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a01b0000c5534a6d45904580d6de55850">CalculateHollowCircleProperties</a> (double outer_diameter, double wall_thickness, double nu=0.33)</td></tr>
<tr class="memdesc:a01b0000c5534a6d45904580d6de55850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates geometric properties for a hollow circular cross-section.  <br /></td></tr>
<tr class="separator:a01b0000c5534a6d45904580d6de55850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba008b3bc6e6267dedceab420db6a548" id="r_aba008b3bc6e6267dedceab420db6a548"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structopenturbine_1_1BeamSection.html">BeamSection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aba008b3bc6e6267dedceab420db6a548">GenerateHollowCircleSection</a> (double s, double E, double G, double rho, double outer_diameter, double wall_thickness, double nu, double x_C=0., double y_C=0., double theta_p=0., double x_S=0., double y_S=0., double theta_s=0., double x_G=0., double y_G=0., double theta_i=0)</td></tr>
<tr class="memdesc:aba008b3bc6e6267dedceab420db6a548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a <a class="el" href="structopenturbine_1_1BeamSection.html">BeamSection</a> with 6x6 mass and stiffness matrices for a hollow circular cross-section.  <br /></td></tr>
<tr class="separator:aba008b3bc6e6267dedceab420db6a548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8211d7f6377e8997cc7bc582b0026cf1" id="r_a8211d7f6377e8997cc7bc582b0026cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a8211d7f6377e8997cc7bc582b0026cf1">LinearInterpWeights</a> (double x, const std::vector&lt; double &gt; &amp;xs, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a8211d7f6377e8997cc7bc582b0026cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weights for linear interpolation.  <br /></td></tr>
<tr class="separator:a8211d7f6377e8997cc7bc582b0026cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db20fcfb13ca8cebee42efbe709969c" id="r_a1db20fcfb13ca8cebee42efbe709969c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a1db20fcfb13ca8cebee42efbe709969c">LinearInterp</a> (double x, const std::vector&lt; double &gt; &amp;xs, const std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:a1db20fcfb13ca8cebee42efbe709969c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes linear interpolation.  <br /></td></tr>
<tr class="separator:a1db20fcfb13ca8cebee42efbe709969c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5798912cd717bfcb31c8740afd46d9dc" id="r_a5798912cd717bfcb31c8740afd46d9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a5798912cd717bfcb31c8740afd46d9dc">LagrangePolynomialInterpWeights</a> (double x, const std::vector&lt; double &gt; &amp;xs, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a5798912cd717bfcb31c8740afd46d9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weights for Lagrange polynomial interpolation.  <br /></td></tr>
<tr class="separator:a5798912cd717bfcb31c8740afd46d9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d02ced85c6d34a155ffe003d33044b" id="r_a62d02ced85c6d34a155ffe003d33044b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a62d02ced85c6d34a155ffe003d33044b">LagrangePolynomialDerivWeights</a> (double x, const std::vector&lt; double &gt; &amp;xs, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a62d02ced85c6d34a155ffe003d33044b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weights for Lagrange polynomial derivative interpolation.  <br /></td></tr>
<tr class="separator:a62d02ced85c6d34a155ffe003d33044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2500bd75d55b14e075f84f7d639ad79c" id="r_a2500bd75d55b14e075f84f7d639ad79c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a2500bd75d55b14e075f84f7d639ad79c">LegendrePolynomial</a> (const size_t n, const double x)</td></tr>
<tr class="memdesc:a2500bd75d55b14e075f84f7d639ad79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the value of Legendre polynomial of order n at point x.  <br /></td></tr>
<tr class="separator:a2500bd75d55b14e075f84f7d639ad79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb44d63028c659a18ee7fd14ac650550" id="r_aeb44d63028c659a18ee7fd14ac650550"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aeb44d63028c659a18ee7fd14ac650550">GenerateGLLPoints</a> (const size_t order)</td></tr>
<tr class="memdesc:aeb44d63028c659a18ee7fd14ac650550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates Gauss-Lobatto-Legendre (GLL) points for spectral element discretization.  <br /></td></tr>
<tr class="separator:aeb44d63028c659a18ee7fd14ac650550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb9136254ef248f7b5f0d886d72bfca" id="r_acbb9136254ef248f7b5f0d886d72bfca"><td class="memTemplParams" colspan="2">template&lt;typename shape_matrix_type , typename node_type , typename qp_type &gt; </td></tr>
<tr class="memitem:acbb9136254ef248f7b5f0d886d72bfca"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#acbb9136254ef248f7b5f0d886d72bfca">InterpVector3</a> (const shape_matrix_type &amp;shape_matrix, const node_type &amp;node_v, const qp_type &amp;qp_v)</td></tr>
<tr class="separator:acbb9136254ef248f7b5f0d886d72bfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667fba0d91a01b1a395f788b4663667d" id="r_a667fba0d91a01b1a395f788b4663667d"><td class="memTemplParams" colspan="2">template&lt;typename shape_matrix_type , typename node_type , typename qp_type &gt; </td></tr>
<tr class="memitem:a667fba0d91a01b1a395f788b4663667d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a667fba0d91a01b1a395f788b4663667d">InterpVector4</a> (const shape_matrix_type &amp;shape_matrix, const node_type &amp;node_v, const qp_type &amp;qp_v)</td></tr>
<tr class="separator:a667fba0d91a01b1a395f788b4663667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b6f9362da1ff2adc401aebee75d68e" id="r_ac8b6f9362da1ff2adc401aebee75d68e"><td class="memTemplParams" colspan="2">template&lt;typename shape_matrix_type , typename node_type , typename qp_type &gt; </td></tr>
<tr class="memitem:ac8b6f9362da1ff2adc401aebee75d68e"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac8b6f9362da1ff2adc401aebee75d68e">InterpQuaternion</a> (const shape_matrix_type &amp;shape_matrix, const node_type &amp;node_v, const qp_type &amp;qp_v)</td></tr>
<tr class="separator:ac8b6f9362da1ff2adc401aebee75d68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e7fae4215fdf08b8bddcc22e56ccdb" id="r_a13e7fae4215fdf08b8bddcc22e56ccdb"><td class="memTemplParams" colspan="2">template&lt;typename shape_matrix_type , typename jacobian_type , typename node_type , typename qp_type &gt; </td></tr>
<tr class="memitem:a13e7fae4215fdf08b8bddcc22e56ccdb"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a13e7fae4215fdf08b8bddcc22e56ccdb">InterpVector3Deriv</a> (const shape_matrix_type &amp;shape_matrix_deriv, const jacobian_type &amp;jacobian, const node_type &amp;node_v, const qp_type &amp;qp_v)</td></tr>
<tr class="separator:a13e7fae4215fdf08b8bddcc22e56ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36ce634a21ee775c8246f924dc2fd2d" id="r_ae36ce634a21ee775c8246f924dc2fd2d"><td class="memTemplParams" colspan="2">template&lt;typename shape_matrix_type , typename jacobian_type , typename node_type , typename qp_type &gt; </td></tr>
<tr class="memitem:ae36ce634a21ee775c8246f924dc2fd2d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ae36ce634a21ee775c8246f924dc2fd2d">InterpVector4Deriv</a> (const shape_matrix_type &amp;shape_matrix_deriv, const jacobian_type &amp;jacobian, const node_type &amp;node_v, const qp_type &amp;qp_v)</td></tr>
<tr class="separator:ae36ce634a21ee775c8246f924dc2fd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888000afce26299dbe662ce083412bab" id="r_a888000afce26299dbe662ce083412bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a888000afce26299dbe662ce083412bab">PopulateNodeX0</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes, const Kokkos::View&lt; double *[7], Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;node_x0)</td></tr>
<tr class="memdesc:a888000afce26299dbe662ce083412bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the node initial position and orientation.  <br /></td></tr>
<tr class="separator:a888000afce26299dbe662ce083412bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4610aa881d666d9e5bddb6a5067339c2" id="r_a4610aa881d666d9e5bddb6a5067339c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a4610aa881d666d9e5bddb6a5067339c2">PopulateQPWeight</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem, const Kokkos::View&lt; double *, Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;qp_weight)</td></tr>
<tr class="memdesc:a4610aa881d666d9e5bddb6a5067339c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the integration weights at each quadrature point.  <br /></td></tr>
<tr class="separator:a4610aa881d666d9e5bddb6a5067339c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45278089c85b116e991de15af3ac44ce" id="r_a45278089c85b116e991de15af3ac44ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a45278089c85b116e991de15af3ac44ce">MapNodePositions</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a45278089c85b116e991de15af3ac44ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map node positions from [0,1] to [-1,1].  <br /></td></tr>
<tr class="separator:a45278089c85b116e991de15af3ac44ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12109372869418dcc0abca332b0d6c5" id="r_aa12109372869418dcc0abca332b0d6c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aa12109372869418dcc0abca332b0d6c5">PopulateShapeFunctionValues</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes, const Kokkos::View&lt; double **, Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;shape_interp)</td></tr>
<tr class="memdesc:aa12109372869418dcc0abca332b0d6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate shape function values at each quadrature point.  <br /></td></tr>
<tr class="separator:aa12109372869418dcc0abca332b0d6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c08713ed08661e503dd8c5b5f16b2b" id="r_ad4c08713ed08661e503dd8c5b5f16b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ad4c08713ed08661e503dd8c5b5f16b2b">PopulateShapeFunctionDerivatives</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes, const Kokkos::View&lt; double **, Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;shape_deriv)</td></tr>
<tr class="memdesc:ad4c08713ed08661e503dd8c5b5f16b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate shape function derivatives at each quadrature point.  <br /></td></tr>
<tr class="separator:ad4c08713ed08661e503dd8c5b5f16b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaadd42bbad5c5402c33c5dbdb445179" id="r_aeaadd42bbad5c5402c33c5dbdb445179"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aeaadd42bbad5c5402c33c5dbdb445179">MapSectionPositions</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem)</td></tr>
<tr class="memdesc:aeaadd42bbad5c5402c33c5dbdb445179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map section positions from [0,1] to [-1,1].  <br /></td></tr>
<tr class="separator:aeaadd42bbad5c5402c33c5dbdb445179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c1b8370d0c393e360ce3a358460901" id="r_aa6c1b8370d0c393e360ce3a358460901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aa6c1b8370d0c393e360ce3a358460901">PopulateQPMstar</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem, const Kokkos::View&lt; double *[6][6], Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;qp_Mstar)</td></tr>
<tr class="memdesc:aa6c1b8370d0c393e360ce3a358460901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate mass matrix values at each quadrature point.  <br /></td></tr>
<tr class="separator:aa6c1b8370d0c393e360ce3a358460901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04aed28bc5a0aa6e48f1f1d3fdd7590" id="r_ad04aed28bc5a0aa6e48f1f1d3fdd7590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ad04aed28bc5a0aa6e48f1f1d3fdd7590">PopulateQPCstar</a> (const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;elem, const Kokkos::View&lt; double *[6][6], Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;qp_Cstar)</td></tr>
<tr class="memdesc:ad04aed28bc5a0aa6e48f1f1d3fdd7590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate stiffness matrix values at each quadrature point.  <br /></td></tr>
<tr class="separator:ad04aed28bc5a0aa6e48f1f1d3fdd7590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7998ef9f2338d934f86b295c4c659da8" id="r_a7998ef9f2338d934f86b295c4c659da8"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a7998ef9f2338d934f86b295c4c659da8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenturbine_1_1Masses.html">Masses</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a7998ef9f2338d934f86b295c4c659da8">CreateMasses</a> (const <a class="el" href="structopenturbine_1_1MassesInput.html">MassesInput</a> &amp;masses_input, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a7998ef9f2338d934f86b295c4c659da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740a2e9d6bd4f113add8c965e67d09d9" id="r_a740a2e9d6bd4f113add8c965e67d09d9"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a740a2e9d6bd4f113add8c965e67d09d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenturbine_1_1Springs.html">Springs</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a740a2e9d6bd4f113add8c965e67d09d9">CreateSprings</a> (const <a class="el" href="structopenturbine_1_1SpringsInput.html">SpringsInput</a> &amp;springs_input, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a740a2e9d6bd4f113add8c965e67d09d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0205ddd45198a3c2892ebfb251c18be6" id="r_a0205ddd45198a3c2892ebfb251c18be6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a0205ddd45198a3c2892ebfb251c18be6">MapGeometricLocations</a> (const std::vector&lt; double &gt; &amp;geom_locations)</td></tr>
<tr class="memdesc:a0205ddd45198a3c2892ebfb251c18be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps input geometric locations -&gt; normalized domain using linear mapping.  <br /></td></tr>
<tr class="separator:a0205ddd45198a3c2892ebfb251c18be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaebb059748c7ce168f6805f1d5dffaf" id="r_acaebb059748c7ce168f6805f1d5dffaf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#acaebb059748c7ce168f6805f1d5dffaf">ComputeShapeFunctionValues</a> (const std::vector&lt; double &gt; &amp;input_points, const std::vector&lt; double &gt; &amp;output_points)</td></tr>
<tr class="memdesc:acaebb059748c7ce168f6805f1d5dffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes shape function matrices œïg relating points Œæb to Œæg.  <br /></td></tr>
<tr class="separator:acaebb059748c7ce168f6805f1d5dffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd2e5475f8dbe9b31462d40b246ea9c" id="r_a4cd2e5475f8dbe9b31462d40b246ea9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a4cd2e5475f8dbe9b31462d40b246ea9c">ComputeShapeFunctionDerivatives</a> (const std::vector&lt; double &gt; &amp;input_points, const std::vector&lt; double &gt; &amp;output_points)</td></tr>
<tr class="memdesc:a4cd2e5475f8dbe9b31462d40b246ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes shape function derivatives dœïg relating points Œæb to Œæg.  <br /></td></tr>
<tr class="separator:a4cd2e5475f8dbe9b31462d40b246ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ac2ab5492e98dbb225554c19dc9935" id="r_a55ac2ab5492e98dbb225554c19dc9935"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a55ac2ab5492e98dbb225554c19dc9935">PerformLeastSquaresFitting</a> (size_t p, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;shape_functions, const std::vector&lt; std::array&lt; double, 3 &gt; &gt; &amp;points_to_fit)</td></tr>
<tr class="memdesc:a55ac2ab5492e98dbb225554c19dc9935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs least squares fitting to determine interpolation coefficients.  <br /></td></tr>
<tr class="separator:a55ac2ab5492e98dbb225554c19dc9935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498f87995034d11d49febc2ade533d52" id="r_a498f87995034d11d49febc2ade533d52"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a498f87995034d11d49febc2ade533d52"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a498f87995034d11d49febc2ade533d52">AX_Matrix</a> (const Matrix &amp;A, const Matrix &amp;AX_A)</td></tr>
<tr class="memdesc:a498f87995034d11d49febc2ade533d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes AX(A) of a square matrix.  <br /></td></tr>
<tr class="separator:a498f87995034d11d49febc2ade533d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11ae3045eb70cfa713334bbfdb9221b" id="r_af11ae3045eb70cfa713334bbfdb9221b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Vector &gt; </td></tr>
<tr class="memitem:af11ae3045eb70cfa713334bbfdb9221b"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#af11ae3045eb70cfa713334bbfdb9221b">AxialVectorOfMatrix</a> (const Matrix &amp;m, const Vector &amp;v)</td></tr>
<tr class="memdesc:af11ae3045eb70cfa713334bbfdb9221b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the axial vector (also known as the vector representation) of a 3x3 skew-symmetric matrix.  <br /></td></tr>
<tr class="separator:af11ae3045eb70cfa713334bbfdb9221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cc33bc27f5f5b4f66cf4f33ed1db98" id="r_a13cc33bc27f5f5b4f66cf4f33ed1db98"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a13cc33bc27f5f5b4f66cf4f33ed1db98">RotateMatrix6</a> (const std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; &amp;m, const std::array&lt; double, 4 &gt; &amp;q)</td></tr>
<tr class="separator:a13cc33bc27f5f5b4f66cf4f33ed1db98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac477866f341264e321869bc6d75c0852" id="r_ac477866f341264e321869bc6d75c0852"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac477866f341264e321869bc6d75c0852">ProjectPointsToTargetPolynomial</a> (size_t num_inputs, size_t num_outputs, const std::vector&lt; std::array&lt; double, 3 &gt; &gt; &amp;input_points)</td></tr>
<tr class="memdesc:ac477866f341264e321869bc6d75c0852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects 3D points from a given (lower) polynomial representation to a target (higher) polynomial representation.  <br /></td></tr>
<tr class="separator:ac477866f341264e321869bc6d75c0852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6031a1228dd8c9d2d5340a579a2b7c8c" id="r_a6031a1228dd8c9d2d5340a579a2b7c8c"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename RotationMatrix &gt; </td></tr>
<tr class="memitem:a6031a1228dd8c9d2d5340a579a2b7c8c"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a6031a1228dd8c9d2d5340a579a2b7c8c">QuaternionToRotationMatrix</a> (const Quaternion &amp;q, const RotationMatrix &amp;R)</td></tr>
<tr class="memdesc:a6031a1228dd8c9d2d5340a579a2b7c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result.  <br /></td></tr>
<tr class="separator:a6031a1228dd8c9d2d5340a579a2b7c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b5090e9b8913c75677a4c99c106537" id="r_a17b5090e9b8913c75677a4c99c106537"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a17b5090e9b8913c75677a4c99c106537">QuaternionToRotationMatrix</a> (const std::array&lt; double, 4 &gt; &amp;q)</td></tr>
<tr class="memdesc:a17b5090e9b8913c75677a4c99c106537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result.  <br /></td></tr>
<tr class="separator:a17b5090e9b8913c75677a4c99c106537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad506ebe71e7afd1ba6b40eeafd959d9f" id="r_ad506ebe71e7afd1ba6b40eeafd959d9f"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ad506ebe71e7afd1ba6b40eeafd959d9f">RotationMatrixToQuaternion</a> (const std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt; &amp;m)</td></tr>
<tr class="memdesc:ad506ebe71e7afd1ba6b40eeafd959d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3x3 rotation matrix to a 4x1 quaternion and returns the result, see <a href="https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/">https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</a> for implementation details.  <br /></td></tr>
<tr class="separator:ad506ebe71e7afd1ba6b40eeafd959d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72faf839870c2324c1201669f4874fd" id="r_ac72faf839870c2324c1201669f4874fd"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename View1 , typename View2 &gt; </td></tr>
<tr class="memitem:ac72faf839870c2324c1201669f4874fd"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac72faf839870c2324c1201669f4874fd">RotateVectorByQuaternion</a> (const Quaternion &amp;q, const View1 &amp;v, const View2 &amp;v_rot)</td></tr>
<tr class="memdesc:ac72faf839870c2324c1201669f4874fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates provided vector by provided <em>unit</em> quaternion and returns the result.  <br /></td></tr>
<tr class="separator:ac72faf839870c2324c1201669f4874fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e80ed01a40636e26fda570566c8712f" id="r_a1e80ed01a40636e26fda570566c8712f"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a1e80ed01a40636e26fda570566c8712f">RotateVectorByQuaternion</a> (const std::array&lt; double, 4 &gt; &amp;q, const std::array&lt; double, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:a1e80ed01a40636e26fda570566c8712f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates provided vector by provided <em>unit</em> quaternion and returns the result.  <br /></td></tr>
<tr class="separator:a1e80ed01a40636e26fda570566c8712f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a13950d555c0d5711557490e098167" id="r_ad1a13950d555c0d5711557490e098167"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename Matrix &gt; </td></tr>
<tr class="memitem:ad1a13950d555c0d5711557490e098167"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ad1a13950d555c0d5711557490e098167">QuaternionDerivative</a> (const Quaternion &amp;q, const Matrix &amp;m)</td></tr>
<tr class="memdesc:ad1a13950d555c0d5711557490e098167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of a quaternion and stores the result in a 3x4 matrix.  <br /></td></tr>
<tr class="separator:ad1a13950d555c0d5711557490e098167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ca747f32ff26a16f5338a76bd5ce76" id="r_a92ca747f32ff26a16f5338a76bd5ce76"><td class="memTemplParams" colspan="2">template&lt;typename QuaternionInput , typename QuaternionOutput &gt; </td></tr>
<tr class="memitem:a92ca747f32ff26a16f5338a76bd5ce76"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a92ca747f32ff26a16f5338a76bd5ce76">QuaternionInverse</a> (const QuaternionInput &amp;q_in, const QuaternionOutput &amp;q_out)</td></tr>
<tr class="memdesc:a92ca747f32ff26a16f5338a76bd5ce76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a quaternion.  <br /></td></tr>
<tr class="separator:a92ca747f32ff26a16f5338a76bd5ce76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4cf00f5ca47c84e3062aca99acb262" id="r_aed4cf00f5ca47c84e3062aca99acb262"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion1 , typename Quaternion2 , typename QuaternionN &gt; </td></tr>
<tr class="memitem:aed4cf00f5ca47c84e3062aca99acb262"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aed4cf00f5ca47c84e3062aca99acb262">QuaternionCompose</a> (const Quaternion1 &amp;q1, const Quaternion2 &amp;q2, QuaternionN &amp;qn)</td></tr>
<tr class="memdesc:aed4cf00f5ca47c84e3062aca99acb262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes (i.e. multiplies) two quaternions and stores the result in a third quaternion.  <br /></td></tr>
<tr class="separator:aed4cf00f5ca47c84e3062aca99acb262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98638bb9e8aed28dc1e2d23a74e5dcc" id="r_aa98638bb9e8aed28dc1e2d23a74e5dcc"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aa98638bb9e8aed28dc1e2d23a74e5dcc">QuaternionCompose</a> (const std::array&lt; double, 4 &gt; &amp;q1, const std::array&lt; double, 4 &gt; &amp;q2)</td></tr>
<tr class="memdesc:aa98638bb9e8aed28dc1e2d23a74e5dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes (i.e. multiplies) two quaternions and returns the result.  <br /></td></tr>
<tr class="separator:aa98638bb9e8aed28dc1e2d23a74e5dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f941e64c14f9edcfb3d8f62efc34633" id="r_a9f941e64c14f9edcfb3d8f62efc34633"><td class="memTemplParams" colspan="2">template&lt;typename Vector , typename Quaternion &gt; </td></tr>
<tr class="memitem:a9f941e64c14f9edcfb3d8f62efc34633"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a9f941e64c14f9edcfb3d8f62efc34633">RotationVectorToQuaternion</a> (const Vector &amp;phi, const Quaternion &amp;quaternion)</td></tr>
<tr class="memdesc:a9f941e64c14f9edcfb3d8f62efc34633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map.  <br /></td></tr>
<tr class="separator:a9f941e64c14f9edcfb3d8f62efc34633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2a49772ed693d1c27ac4e630d4fbe5" id="r_a9c2a49772ed693d1c27ac4e630d4fbe5"><td class="memTemplParams" colspan="2">template&lt;typename Quaternion , typename Vector &gt; </td></tr>
<tr class="memitem:a9c2a49772ed693d1c27ac4e630d4fbe5"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a9c2a49772ed693d1c27ac4e630d4fbe5">QuaternionToRotationVector</a> (const Quaternion &amp;quaternion, const Vector &amp;phi)</td></tr>
<tr class="memdesc:a9c2a49772ed693d1c27ac4e630d4fbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 3-D rotation vector from provided 4-D quaternion, i.e. the logarithmic map.  <br /></td></tr>
<tr class="separator:a9c2a49772ed693d1c27ac4e630d4fbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedcc4f8cff54577c5845a63f86442ea" id="r_aaedcc4f8cff54577c5845a63f86442ea"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aaedcc4f8cff54577c5845a63f86442ea">QuaternionToRotationVector</a> (const std::array&lt; double, 4 &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:aaedcc4f8cff54577c5845a63f86442ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 3-D rotation vector from provided 4-D quaternion.  <br /></td></tr>
<tr class="separator:aaedcc4f8cff54577c5845a63f86442ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f9cb90556cfb4258d7c0e7407df3c" id="r_afe7f9cb90556cfb4258d7c0e7407df3c"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#afe7f9cb90556cfb4258d7c0e7407df3c">RotationVectorToQuaternion</a> (const std::array&lt; double, 3 &gt; &amp;phi)</td></tr>
<tr class="memdesc:afe7f9cb90556cfb4258d7c0e7407df3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map.  <br /></td></tr>
<tr class="separator:afe7f9cb90556cfb4258d7c0e7407df3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b39de2d4c5546c48b34c5f3f8bfa71" id="r_ac8b39de2d4c5546c48b34c5f3f8bfa71"><td class="memItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION Kokkos::Array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ac8b39de2d4c5546c48b34c5f3f8bfa71">NormalizeQuaternion</a> (const Kokkos::Array&lt; double, 4 &gt; &amp;q)</td></tr>
<tr class="memdesc:ac8b39de2d4c5546c48b34c5f3f8bfa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a quaternion to ensure it is a unit quaternion.  <br /></td></tr>
<tr class="separator:ac8b39de2d4c5546c48b34c5f3f8bfa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09592817ae601310d569910e7603cc4a" id="r_a09592817ae601310d569910e7603cc4a"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a09592817ae601310d569910e7603cc4a">TangentTwistToQuaternion</a> (const std::array&lt; double, 3 &gt; &amp;tangent, const double twist)</td></tr>
<tr class="memdesc:a09592817ae601310d569910e7603cc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4-D quaternion from provided tangent vector and twist (degrees) about tangent.  <br /></td></tr>
<tr class="separator:a09592817ae601310d569910e7603cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ae7ec2f79c8519eb93122773096413" id="r_ad3ae7ec2f79c8519eb93122773096413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ad3ae7ec2f79c8519eb93122773096413">IsIdentityQuaternion</a> (const std::array&lt; double, 4 &gt; &amp;q, double tolerance=1e-12)</td></tr>
<tr class="memdesc:ad3ae7ec2f79c8519eb93122773096413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a quaternion is approximately the identity quaternion [1, 0, 0, 0].  <br /></td></tr>
<tr class="separator:ad3ae7ec2f79c8519eb93122773096413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b4aa8d797ea86827404834f2a0173d" id="r_a27b4aa8d797ea86827404834f2a0173d"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename MatrixType &gt; </td></tr>
<tr class="memitem:a27b4aa8d797ea86827404834f2a0173d"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a27b4aa8d797ea86827404834f2a0173d">VecTilde</a> (const VectorType &amp;vector, const MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:a27b4aa8d797ea86827404834f2a0173d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3x1 vector to a 3x3 skew-symmetric matrix and returns the result.  <br /></td></tr>
<tr class="separator:a27b4aa8d797ea86827404834f2a0173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb204ad9bcd513584bec614a7f8bad51" id="r_acb204ad9bcd513584bec614a7f8bad51"><td class="memTemplParams" colspan="2">template&lt;typename AVectorType , typename BVectorType &gt; </td></tr>
<tr class="memitem:acb204ad9bcd513584bec614a7f8bad51"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#acb204ad9bcd513584bec614a7f8bad51">DotProduct</a> (const AVectorType &amp;a, const BVectorType &amp;b)</td></tr>
<tr class="memdesc:acb204ad9bcd513584bec614a7f8bad51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dot product between two vector views.  <br /></td></tr>
<tr class="separator:acb204ad9bcd513584bec614a7f8bad51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fd260429a217254a1f7fefd06f1d0c" id="r_a93fd260429a217254a1f7fefd06f1d0c"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a93fd260429a217254a1f7fefd06f1d0c">DotProduct</a> (const std::array&lt; double, 3 &gt; &amp;a, const std::array&lt; double, 3 &gt; &amp;b)</td></tr>
<tr class="memdesc:a93fd260429a217254a1f7fefd06f1d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dot product between two vector views.  <br /></td></tr>
<tr class="separator:a93fd260429a217254a1f7fefd06f1d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e9b029e366a7f2939f8e4b6368e6f1" id="r_a11e9b029e366a7f2939f8e4b6368e6f1"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a11e9b029e366a7f2939f8e4b6368e6f1"><td class="memTemplItemLeft" align="right" valign="top">KOKKOS_INLINE_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a11e9b029e366a7f2939f8e4b6368e6f1">CrossProduct</a> (const VectorType &amp;a, const VectorType &amp;b, const VectorType &amp;c)</td></tr>
<tr class="memdesc:a11e9b029e366a7f2939f8e4b6368e6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cross product between two vector views.  <br /></td></tr>
<tr class="separator:a11e9b029e366a7f2939f8e4b6368e6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85674de16e16e900744aea882cd70c77" id="r_a85674de16e16e900744aea882cd70c77"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a85674de16e16e900744aea882cd70c77">CrossProduct</a> (const std::array&lt; double, 3 &gt; &amp;a, const std::array&lt; double, 3 &gt; &amp;b)</td></tr>
<tr class="memdesc:a85674de16e16e900744aea882cd70c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cross product between two vectors.  <br /></td></tr>
<tr class="separator:a85674de16e16e900744aea882cd70c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad27565ccfd45b311fc65fd9a78790b" id="r_a3ad27565ccfd45b311fc65fd9a78790b"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a3ad27565ccfd45b311fc65fd9a78790b">Norm</a> (const std::array&lt; double, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:a3ad27565ccfd45b311fc65fd9a78790b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the norm of a given vector.  <br /></td></tr>
<tr class="separator:a3ad27565ccfd45b311fc65fd9a78790b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee5cd7f43dea8ac0f9a706cca255e62" id="r_adee5cd7f43dea8ac0f9a706cca255e62"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#adee5cd7f43dea8ac0f9a706cca255e62">UnitVector</a> (const std::array&lt; double, 3 &gt; &amp;v)</td></tr>
<tr class="memdesc:adee5cd7f43dea8ac0f9a706cca255e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnitVector returns the unit vector of the given vector.  <br /></td></tr>
<tr class="separator:adee5cd7f43dea8ac0f9a706cca255e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ee64780a3fb5ae6e53fa9b901db66d" id="r_a04ee64780a3fb5ae6e53fa9b901db66d"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a04ee64780a3fb5ae6e53fa9b901db66d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a04ee64780a3fb5ae6e53fa9b901db66d">CopyNodesToState</a> (<a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state, const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a04ee64780a3fb5ae6e53fa9b901db66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a407ea76de5afb5078a4c76b4c59495" id="r_a7a407ea76de5afb5078a4c76b4c59495"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType  = Kokkos::Device&lt;Kokkos::DefaultExecutionSpace, Kokkos::DefaultExecutionSpace::memory_space&gt;&gt; </td></tr>
<tr class="memitem:a7a407ea76de5afb5078a4c76b4c59495"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a7a407ea76de5afb5078a4c76b4c59495">CreateSolver</a> (<a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state, <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;elements, <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="memdesc:a7a407ea76de5afb5078a4c76b4c59495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute freedom tables for state, elements, and constraints, then construct and return solver.  <br /></td></tr>
<tr class="separator:a7a407ea76de5afb5078a4c76b4c59495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba456c8b86c4960edec901de54f9c62e" id="r_aba456c8b86c4960edec901de54f9c62e"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:aba456c8b86c4960edec901de54f9c62e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aba456c8b86c4960edec901de54f9c62e">ComputeNumSystemDofs</a> (const typename Kokkos::View&lt; size_t *, DeviceType &gt;::const_type &amp;active_dofs)</td></tr>
<tr class="memdesc:aba456c8b86c4960edec901de54f9c62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total number of active degrees of freedom in the system.  <br /></td></tr>
<tr class="separator:aba456c8b86c4960edec901de54f9c62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ca657b6802690caf59a751895988b7" id="r_ab7ca657b6802690caf59a751895988b7"><td class="memTemplParams" colspan="2">template&lt;typename DSSHandleType , typename CrsMatrixType &gt; </td></tr>
<tr class="memitem:ab7ca657b6802690caf59a751895988b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ab7ca657b6802690caf59a751895988b7">dss_numeric</a> (DSSHandleType &amp;dss_handle, CrsMatrixType &amp;A)</td></tr>
<tr class="separator:ab7ca657b6802690caf59a751895988b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6218493b464b10ca4569eb0e85971e9" id="r_ab6218493b464b10ca4569eb0e85971e9"><td class="memTemplParams" colspan="2">template&lt;typename DSSHandleType , typename CrsMatrixType , typename MultiVectorType &gt; </td></tr>
<tr class="memitem:ab6218493b464b10ca4569eb0e85971e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ab6218493b464b10ca4569eb0e85971e9">dss_solve</a> (DSSHandleType &amp;dss_handle, CrsMatrixType &amp;A, MultiVectorType &amp;b, MultiVectorType &amp;x)</td></tr>
<tr class="separator:ab6218493b464b10ca4569eb0e85971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faae3763d2c59be117c6fb7a48e8289" id="r_a5faae3763d2c59be117c6fb7a48e8289"><td class="memTemplParams" colspan="2">template&lt;typename DSSHandleType , typename CrsMatrixType &gt; </td></tr>
<tr class="memitem:a5faae3763d2c59be117c6fb7a48e8289"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a5faae3763d2c59be117c6fb7a48e8289">dss_symbolic</a> (DSSHandleType &amp;dss_handle, CrsMatrixType &amp;A)</td></tr>
<tr class="separator:a5faae3763d2c59be117c6fb7a48e8289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794447995e27871f70d7acf0f3f13747" id="r_a794447995e27871f70d7acf0f3f13747"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a794447995e27871f70d7acf0f3f13747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a794447995e27871f70d7acf0f3f13747">CloneState</a> (const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;old)</td></tr>
<tr class="separator:a794447995e27871f70d7acf0f3f13747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af04c0e5a2a9870a95b10edd29cc3f4" id="r_a3af04c0e5a2a9870a95b10edd29cc3f4"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a3af04c0e5a2a9870a95b10edd29cc3f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a3af04c0e5a2a9870a95b10edd29cc3f4">CopyStateData</a> (<a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;copy, const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;old)</td></tr>
<tr class="separator:a3af04c0e5a2a9870a95b10edd29cc3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824a1ec66835921088c4dfc658322095" id="r_a824a1ec66835921088c4dfc658322095"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a824a1ec66835921088c4dfc658322095"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a824a1ec66835921088c4dfc658322095">ReadStateFromFile</a> (std::istream &amp;input, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:a824a1ec66835921088c4dfc658322095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62af0f1efb9ba7a0937e98e71f34e0ef" id="r_a62af0f1efb9ba7a0937e98e71f34e0ef"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a62af0f1efb9ba7a0937e98e71f34e0ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a62af0f1efb9ba7a0937e98e71f34e0ef">WriteStateToFile</a> (std::ostream &amp;output, const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:a62af0f1efb9ba7a0937e98e71f34e0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a1c1ca0eaaf2697da6b979d2cf9de6" id="r_a91a1c1ca0eaaf2697da6b979d2cf9de6"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a91a1c1ca0eaaf2697da6b979d2cf9de6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a91a1c1ca0eaaf2697da6b979d2cf9de6">AssembleConstraintsMatrix</a> (<a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="separator:a91a1c1ca0eaaf2697da6b979d2cf9de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e2795cf65aea8db173b3fd1396e65" id="r_a8a5e2795cf65aea8db173b3fd1396e65"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a8a5e2795cf65aea8db173b3fd1396e65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a8a5e2795cf65aea8db173b3fd1396e65">AssembleConstraintsResidual</a> (<a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="separator:a8a5e2795cf65aea8db173b3fd1396e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59612cdaf821fd088101c76db997c4" id="r_a0e59612cdaf821fd088101c76db997c4"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a0e59612cdaf821fd088101c76db997c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a0e59612cdaf821fd088101c76db997c4">AssembleSystemMatrix</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, <a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;elements)</td></tr>
<tr class="separator:a0e59612cdaf821fd088101c76db997c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36566437e3b617bfdc718e6d33f273c6" id="r_a36566437e3b617bfdc718e6d33f273c6"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a36566437e3b617bfdc718e6d33f273c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a36566437e3b617bfdc718e6d33f273c6">AssembleSystemResidual</a> (<a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;elements, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:a36566437e3b617bfdc718e6d33f273c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f75a93db6a6068eb5759ec7125ac8d" id="r_a81f75a93db6a6068eb5759ec7125ac8d"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a81f75a93db6a6068eb5759ec7125ac8d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a81f75a93db6a6068eb5759ec7125ac8d">CalculateConvergenceError</a> (const <a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, const <a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state, const <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="memdesc:a81f75a93db6a6068eb5759ec7125ac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation based on Table 1 of DOI: 10.1115/1.4033441.  <br /></td></tr>
<tr class="separator:a81f75a93db6a6068eb5759ec7125ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87b3510b483752bb7b465629e7180c4" id="r_aa87b3510b483752bb7b465629e7180c4"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:aa87b3510b483752bb7b465629e7180c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aa87b3510b483752bb7b465629e7180c4">PredictNextState</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:aa87b3510b483752bb7b465629e7180c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8777e77beabff02f607c8252c2cefd4" id="r_ad8777e77beabff02f607c8252c2cefd4"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:ad8777e77beabff02f607c8252c2cefd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ad8777e77beabff02f607c8252c2cefd4">ResetConstraints</a> (<a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="separator:ad8777e77beabff02f607c8252c2cefd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c05476e233e348498c9719f6571f8fc" id="r_a9c05476e233e348498c9719f6571f8fc"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a9c05476e233e348498c9719f6571f8fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a9c05476e233e348498c9719f6571f8fc">ResetSolver</a> (<a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver)</td></tr>
<tr class="separator:a9c05476e233e348498c9719f6571f8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f7a5476c025fc05f72cd313619ec9" id="r_aab7f7a5476c025fc05f72cd313619ec9"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:aab7f7a5476c025fc05f72cd313619ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aab7f7a5476c025fc05f72cd313619ec9">SolveSystem</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, <a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver)</td></tr>
<tr class="separator:aab7f7a5476c025fc05f72cd313619ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401e812f3359217f90799a34c5fb37f4" id="r_a401e812f3359217f90799a34c5fb37f4"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a401e812f3359217f90799a34c5fb37f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a401e812f3359217f90799a34c5fb37f4">Step</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, <a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;elements, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state, <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="memdesc:a401e812f3359217f90799a34c5fb37f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to complete a single time step in the dynamic FEA simulation.  <br /></td></tr>
<tr class="separator:a401e812f3359217f90799a34c5fb37f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db6a0642536770dfd1c9864d28b4b99" id="r_a7db6a0642536770dfd1c9864d28b4b99"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a7db6a0642536770dfd1c9864d28b4b99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a7db6a0642536770dfd1c9864d28b4b99">UpdateConstraintPrediction</a> (<a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="separator:a7db6a0642536770dfd1c9864d28b4b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85467e8fa5b8b0757ac1749a12f6640" id="r_ab85467e8fa5b8b0757ac1749a12f6640"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:ab85467e8fa5b8b0757ac1749a12f6640"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ab85467e8fa5b8b0757ac1749a12f6640">UpdateConstraintVariables</a> (<a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state, <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;constraints)</td></tr>
<tr class="separator:ab85467e8fa5b8b0757ac1749a12f6640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab135fd3e4a55b8eafb693d63778d6d0b" id="r_ab135fd3e4a55b8eafb693d63778d6d0b"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:ab135fd3e4a55b8eafb693d63778d6d0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ab135fd3e4a55b8eafb693d63778d6d0b">UpdateStatePrediction</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, const <a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;solver, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:ab135fd3e4a55b8eafb693d63778d6d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb0d78408970e2f5707eb6da6c65656" id="r_aceb0d78408970e2f5707eb6da6c65656"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:aceb0d78408970e2f5707eb6da6c65656"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#aceb0d78408970e2f5707eb6da6c65656">UpdateSystemVariables</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, const <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;elements, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:aceb0d78408970e2f5707eb6da6c65656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ea1c4346ac0e80a41e7986ff1c4ee9" id="r_a97ea1c4346ac0e80a41e7986ff1c4ee9"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a97ea1c4346ac0e80a41e7986ff1c4ee9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a97ea1c4346ac0e80a41e7986ff1c4ee9">UpdateSystemVariablesBeams</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, const <a class="el" href="structopenturbine_1_1Beams.html">Beams</a>&lt; DeviceType &gt; &amp;beams, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:a97ea1c4346ac0e80a41e7986ff1c4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90ea3c8e7997ac4f2ac3057fd591a8c" id="r_ae90ea3c8e7997ac4f2ac3057fd591a8c"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:ae90ea3c8e7997ac4f2ac3057fd591a8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#ae90ea3c8e7997ac4f2ac3057fd591a8c">UpdateSystemVariablesMasses</a> (const <a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, const <a class="el" href="structopenturbine_1_1Masses.html">Masses</a>&lt; DeviceType &gt; &amp;masses, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:ae90ea3c8e7997ac4f2ac3057fd591a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3707277127727af6fe2bf96e37b744" id="r_abd3707277127727af6fe2bf96e37b744"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:abd3707277127727af6fe2bf96e37b744"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#abd3707277127727af6fe2bf96e37b744">UpdateSystemVariablesSprings</a> (const <a class="el" href="structopenturbine_1_1Springs.html">Springs</a>&lt; DeviceType &gt; &amp;springs, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:abd3707277127727af6fe2bf96e37b744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bce4a0ea133697b8166de3f32939445" id="r_a6bce4a0ea133697b8166de3f32939445"><td class="memTemplParams" colspan="2">template&lt;typename DeviceType &gt; </td></tr>
<tr class="memitem:a6bce4a0ea133697b8166de3f32939445"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a6bce4a0ea133697b8166de3f32939445">UpdateTangentOperator</a> (<a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;parameters, <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;state)</td></tr>
<tr class="separator:a6bce4a0ea133697b8166de3f32939445"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a48906c8285184b9678d6334ad3458ef3" id="r_a48906c8285184b9678d6334ad3458ef3"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a48906c8285184b9678d6334ad3458ef3">kMaxIterations</a> {1000}</td></tr>
<tr class="memdesc:a48906c8285184b9678d6334ad3458ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations allowed for Newton's method.  <br /></td></tr>
<tr class="separator:a48906c8285184b9678d6334ad3458ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0e60f1da391382388f44fc056935a1" id="r_a8b0e60f1da391382388f44fc056935a1"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenturbine.html#a8b0e60f1da391382388f44fc056935a1">kConvergenceTolerance</a> {std::numeric_limits&lt;double&gt;::epsilon()}</td></tr>
<tr class="memdesc:a8b0e60f1da391382388f44fc056935a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for Newton's method to machine precision.  <br /></td></tr>
<tr class="separator:a8b0e60f1da391382388f44fc056935a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a86a41c4e6ed003fa419c858b8e6cd18d" name="a86a41c4e6ed003fa419c858b8e6cd18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a41c4e6ed003fa419c858b8e6cd18d">&#9670;&#160;</a></span>ConstraintType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">openturbine::ConstraintType</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18da6adf97f83acf6453d4a6a4b1070f3754" name="a86a41c4e6ed003fa419c858b8e6cd18da6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18da0675be2979017444f65694563143ae05" name="a86a41c4e6ed003fa419c858b8e6cd18da0675be2979017444f65694563143ae05"></a>FixedBC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18da301672e51ad71b8b62f2342e1ed4dd06" name="a86a41c4e6ed003fa419c858b8e6cd18da301672e51ad71b8b62f2342e1ed4dd06"></a>PrescribedBC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18da370a21b7043ed95e6a3edd1148e878af" name="a86a41c4e6ed003fa419c858b8e6cd18da370a21b7043ed95e6a3edd1148e878af"></a>RigidJoint&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18dadc7372c64ce46f9a406934dea0893143" name="a86a41c4e6ed003fa419c858b8e6cd18dadc7372c64ce46f9a406934dea0893143"></a>RevoluteJoint&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18dadfe188d9ca50087680a8c110cc826057" name="a86a41c4e6ed003fa419c858b8e6cd18dadfe188d9ca50087680a8c110cc826057"></a>RotationControl&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18da9874b01bdcca61f405b152e78344d098" name="a86a41c4e6ed003fa419c858b8e6cd18da9874b01bdcca61f405b152e78344d098"></a>FixedBC3DOFs&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18da1a186c7997146fe73e33c92f2559b1e1" name="a86a41c4e6ed003fa419c858b8e6cd18da1a186c7997146fe73e33c92f2559b1e1"></a>PrescribedBC3DOFs&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86a41c4e6ed003fa419c858b8e6cd18dabfcb760f80357f56afc456eed1ea27f3" name="a86a41c4e6ed003fa419c858b8e6cd18dabfcb760f80357f56afc456eed1ea27f3"></a>RigidJoint6DOFsTo3DOFs&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac0b08ab0fe95ca731068f06eae062b5b" name="ac0b08ab0fe95ca731068f06eae062b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b08ab0fe95ca731068f06eae062b5b">&#9670;&#160;</a></span>DSSAlgorithm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceopenturbine.html#ac0b08ab0fe95ca731068f06eae062b5b">openturbine::DSSAlgorithm</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5bae58d2e3a739d6b1f6bdd0daff2288ece" name="ac0b08ab0fe95ca731068f06eae062b5bae58d2e3a739d6b1f6bdd0daff2288ece"></a>CUSOLVER_SP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5ba3283f7ef1b1d9ecc3d65af213a0a8338" name="ac0b08ab0fe95ca731068f06eae062b5ba3283f7ef1b1d9ecc3d65af213a0a8338"></a>CUDSS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5bad4dcdada1c05a280bb7e95da2874fa97" name="ac0b08ab0fe95ca731068f06eae062b5bad4dcdada1c05a280bb7e95da2874fa97"></a>KLU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5bad2a602ed8582b78e22141784e4a86165" name="ac0b08ab0fe95ca731068f06eae062b5bad2a602ed8582b78e22141784e4a86165"></a>UMFPACK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5bae85f79ff3d82385beca51faebc04ab92" name="ac0b08ab0fe95ca731068f06eae062b5bae85f79ff3d82385beca51faebc04ab92"></a>SUPERLU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5ba2b5fb6f9206e24cb33edd6cf64195c31" name="ac0b08ab0fe95ca731068f06eae062b5ba2b5fb6f9206e24cb33edd6cf64195c31"></a>SUPERLU_MT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5ba6a8f79dd53a94059a5cdcd066199a06f" name="ac0b08ab0fe95ca731068f06eae062b5ba6a8f79dd53a94059a5cdcd066199a06f"></a>MKL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac0b08ab0fe95ca731068f06eae062b5bab50339a10e1de285ac99d4c3990b8693" name="ac0b08ab0fe95ca731068f06eae062b5bab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac4a0c4b14f459d6be7082dd819d5e15c" name="ac4a0c4b14f459d6be7082dd819d5e15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a0c4b14f459d6be7082dd819d5e15c">&#9670;&#160;</a></span>FreedomSignature</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">openturbine::FreedomSignature</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the active degrees of freedom for a node. </p>
<p>Each bit in the 6-bit signature represents a degree of freedom:</p><ul>
<li>Bits 5-3: Translational DOFs (x, y, z positions)</li>
<li>Bits 2-0: Rotational DOFs (rx, ry, rz rotations)</li>
</ul>
<p>Binary format: 0b00[Tz][Ty][Tx][Rz][Ry][Rx] </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac4a0c4b14f459d6be7082dd819d5e15ca3b833b799f6bc70091f2d9cf4e10f41e" name="ac4a0c4b14f459d6be7082dd819d5e15ca3b833b799f6bc70091f2d9cf4e10f41e"></a>AllComponents&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac4a0c4b14f459d6be7082dd819d5e15cac3f1ed4c290648ed6b685b415448430d" name="ac4a0c4b14f459d6be7082dd819d5e15cac3f1ed4c290648ed6b685b415448430d"></a>JustPosition&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac4a0c4b14f459d6be7082dd819d5e15ca6bd15481aa8778fbfe716b3aee6fa8be" name="ac4a0c4b14f459d6be7082dd819d5e15ca6bd15481aa8778fbfe716b3aee6fa8be"></a>JustRotation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac4a0c4b14f459d6be7082dd819d5e15cad777bc3d604905978e7e68786d91dd67" name="ac4a0c4b14f459d6be7082dd819d5e15cad777bc3d604905978e7e68786d91dd67"></a>NoComponents&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a932a665948376539c8aa98265a8e8257" name="a932a665948376539c8aa98265a8e8257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932a665948376539c8aa98265a8e8257">&#9670;&#160;</a></span>assemble_node_freedom_allocation_table()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::assemble_node_freedom_allocation_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91a1c1ca0eaaf2697da6b979d2cf9de6" name="a91a1c1ca0eaaf2697da6b979d2cf9de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a1c1ca0eaaf2697da6b979d2cf9de6">&#9670;&#160;</a></span>AssembleConstraintsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::AssembleConstraintsMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a5e2795cf65aea8db173b3fd1396e65" name="a8a5e2795cf65aea8db173b3fd1396e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5e2795cf65aea8db173b3fd1396e65">&#9670;&#160;</a></span>AssembleConstraintsResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::AssembleConstraintsResidual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e59612cdaf821fd088101c76db997c4" name="a0e59612cdaf821fd088101c76db997c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e59612cdaf821fd088101c76db997c4">&#9670;&#160;</a></span>AssembleSystemMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::AssembleSystemMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36566437e3b617bfdc718e6d33f273c6" name="a36566437e3b617bfdc718e6d33f273c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36566437e3b617bfdc718e6d33f273c6">&#9670;&#160;</a></span>AssembleSystemResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::AssembleSystemResidual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a498f87995034d11d49febc2ade533d52" name="a498f87995034d11d49febc2ade533d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498f87995034d11d49febc2ade533d52">&#9670;&#160;</a></span>AX_Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::AX_Matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>AX_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes AX(A) of a square matrix. </p>
<p>AX(A) = tr(A)/2 * I - A/2, where I is the identity matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input square matrix </td></tr>
    <tr><td class="paramname">AX_A</td><td>Output matrix containing the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af11ae3045eb70cfa713334bbfdb9221b" name="af11ae3045eb70cfa713334bbfdb9221b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11ae3045eb70cfa713334bbfdb9221b">&#9670;&#160;</a></span>AxialVectorOfMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::AxialVectorOfMatrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the axial vector (also known as the vector representation) of a 3x3 skew-symmetric matrix. </p>
<p>The axial vector is defined as [w‚ÇÅ, w‚ÇÇ, w‚ÇÉ]·µÄ where: w‚ÇÅ = (m‚ÇÉ‚ÇÇ - m‚ÇÇ‚ÇÉ)/2 w‚ÇÇ = (m‚ÇÅ‚ÇÉ - m‚ÇÉ‚ÇÅ)/2 w‚ÇÉ = (m‚ÇÇ‚ÇÅ - m‚ÇÅ‚ÇÇ)/2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Input 3x3 rotation matrix </td></tr>
    <tr><td class="paramname">v</td><td>Output vector to store the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Matrix m must be 3x3 and vector v must have size 3 </dd></dl>

</div>
</div>
<a id="a81f75a93db6a6068eb5759ec7125ac8d" name="a81f75a93db6a6068eb5759ec7125ac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f75a93db6a6068eb5759ec7125ac8d">&#9670;&#160;</a></span>CalculateConvergenceError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double openturbine::CalculateConvergenceError </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation based on Table 1 of DOI: 10.1115/1.4033441. </p>

</div>
</div>
<a id="a01b0000c5534a6d45904580d6de55850" name="a01b0000c5534a6d45904580d6de55850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b0000c5534a6d45904580d6de55850">&#9670;&#160;</a></span>CalculateHollowCircleProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structopenturbine_1_1HollowCircleProperties.html">HollowCircleProperties</a> openturbine::CalculateHollowCircleProperties </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wall_thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nu</em> = <code>0.33</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates geometric properties for a hollow circular cross-section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer_diameter</td><td>Outer diameter of the hollow circle [Length] </td></tr>
    <tr><td class="paramname">wall_thickness</td><td>Wall thickness [Length] </td></tr>
    <tr><td class="paramname">nu</td><td>Poisson's ratio for shear correction factor calculation [dimensionless]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structopenturbine_1_1HollowCircleProperties.html" title="Struct containing geometric properties for a hollow circular cross-section.">HollowCircleProperties</a> struct containing geometric properties </dd></dl>

</div>
</div>
<a id="a794447995e27871f70d7acf0f3f13747" name="a794447995e27871f70d7acf0f3f13747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794447995e27871f70d7acf0f3f13747">&#9670;&#160;</a></span>CloneState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; openturbine::CloneState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>old</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab306821727cde73c9c0a552c66b62238" name="ab306821727cde73c9c0a552c66b62238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab306821727cde73c9c0a552c66b62238">&#9670;&#160;</a></span>compute_node_freedom_map_table()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::compute_node_freedom_map_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba456c8b86c4960edec901de54f9c62e" name="aba456c8b86c4960edec901de54f9c62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba456c8b86c4960edec901de54f9c62e">&#9670;&#160;</a></span>ComputeNumSystemDofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t openturbine::ComputeNumSystemDofs </td>
          <td>(</td>
          <td class="paramtype">const typename Kokkos::View&lt; size_t *, DeviceType &gt;::const_type &amp;&#160;</td>
          <td class="paramname"><em>active_dofs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the total number of active degrees of freedom in the system. </p>

</div>
</div>
<a id="a4cd2e5475f8dbe9b31462d40b246ea9c" name="a4cd2e5475f8dbe9b31462d40b246ea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd2e5475f8dbe9b31462d40b246ea9c">&#9670;&#160;</a></span>ComputeShapeFunctionDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; openturbine::ComputeShapeFunctionDerivatives </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes shape function derivatives dœïg relating points Œæb to Œæg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_pts</td><td>Input points, Œæb, in [-1, 1] (2 &lt;= input_pts.size() &lt;= output_pts.size()) </td></tr>
    <tr><td class="paramname">output_pts</td><td>Output points, Œæg, in [-1, 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shape function derivative matrix </dd></dl>

</div>
</div>
<a id="acaebb059748c7ce168f6805f1d5dffaf" name="acaebb059748c7ce168f6805f1d5dffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaebb059748c7ce168f6805f1d5dffaf">&#9670;&#160;</a></span>ComputeShapeFunctionValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; openturbine::ComputeShapeFunctionValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes shape function matrices œïg relating points Œæb to Œæg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_pts</td><td>Input points, Œæb, in [-1, 1] (2 &lt;= input_pts.size() &lt;= output_pts.size()) </td></tr>
    <tr><td class="paramname">output_pts</td><td>Output points, Œæg, in [-1, 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shape function matrix </dd></dl>

</div>
</div>
<a id="a04ee64780a3fb5ae6e53fa9b901db66d" name="a04ee64780a3fb5ae6e53fa9b901db66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ee64780a3fb5ae6e53fa9b901db66d">&#9670;&#160;</a></span>CopyNodesToState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::CopyNodesToState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3af04c0e5a2a9870a95b10edd29cc3f4" name="a3af04c0e5a2a9870a95b10edd29cc3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af04c0e5a2a9870a95b10edd29cc3f4">&#9670;&#160;</a></span>CopyStateData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::CopyStateData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac49461f4e15c88f90f8383dffa5ac51b" name="ac49461f4e15c88f90f8383dffa5ac51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49461f4e15c88f90f8383dffa5ac51b">&#9670;&#160;</a></span>count_active_dofs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION size_t openturbine::count_active_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of active degrees of freedom in a signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The freedom signature to count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of active degrees of freedom </dd></dl>

</div>
</div>
<a id="a54288e8047ccc914721bc897928e61cc" name="a54288e8047ccc914721bc897928e61cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54288e8047ccc914721bc897928e61cc">&#9670;&#160;</a></span>create_constraint_freedom_table()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::create_constraint_freedom_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68e93c3fd69a7f4617f67df3a8ece264" name="a68e93c3fd69a7f4617f67df3a8ece264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e93c3fd69a7f4617f67df3a8ece264">&#9670;&#160;</a></span>create_element_freedom_table()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::create_element_freedom_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af984b601608050be09485b044eb900a7" name="af984b601608050be09485b044eb900a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af984b601608050be09485b044eb900a7">&#9670;&#160;</a></span>CreateBeams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenturbine_1_1Beams.html">Beams</a>&lt; DeviceType &gt; openturbine::CreateBeams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamsInput.html">BeamsInput</a> &amp;&#160;</td>
          <td class="paramname"><em>beams_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7998ef9f2338d934f86b295c4c659da8" name="a7998ef9f2338d934f86b295c4c659da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7998ef9f2338d934f86b295c4c659da8">&#9670;&#160;</a></span>CreateMasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenturbine_1_1Masses.html">Masses</a>&lt; DeviceType &gt; openturbine::CreateMasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1MassesInput.html">MassesInput</a> &amp;&#160;</td>
          <td class="paramname"><em>masses_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a407ea76de5afb5078a4c76b4c59495" name="a7a407ea76de5afb5078a4c76b4c59495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a407ea76de5afb5078a4c76b4c59495">&#9670;&#160;</a></span>CreateSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType  = Kokkos::Device&lt;Kokkos::DefaultExecutionSpace, Kokkos::DefaultExecutionSpace::memory_space&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; openturbine::CreateSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute freedom tables for state, elements, and constraints, then construct and return solver. </p>

</div>
</div>
<a id="a740a2e9d6bd4f113add8c965e67d09d9" name="a740a2e9d6bd4f113add8c965e67d09d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740a2e9d6bd4f113add8c965e67d09d9">&#9670;&#160;</a></span>CreateSprings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenturbine_1_1Springs.html">Springs</a>&lt; DeviceType &gt; openturbine::CreateSprings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1SpringsInput.html">SpringsInput</a> &amp;&#160;</td>
          <td class="paramname"><em>springs_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a828012f9e18e6714c1f9ca3ba44d9e5f" name="a828012f9e18e6714c1f9ca3ba44d9e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828012f9e18e6714c1f9ca3ba44d9e5f">&#9670;&#160;</a></span>CreateTrapezoidalQuadrature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; double, 2 &gt; &gt; openturbine::CreateTrapezoidalQuadrature </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85674de16e16e900744aea882cd70c77" name="a85674de16e16e900744aea882cd70c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85674de16e16e900744aea882cd70c77">&#9670;&#160;</a></span>CrossProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; double, 3 &gt; openturbine::CrossProduct </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the cross product between two vectors. </p>

</div>
</div>
<a id="a11e9b029e366a7f2939f8e4b6368e6f1" name="a11e9b029e366a7f2939f8e4b6368e6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e9b029e366a7f2939f8e4b6368e6f1">&#9670;&#160;</a></span>CrossProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::CrossProduct </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cross product between two vector views. </p>

</div>
</div>
<a id="acb204ad9bcd513584bec614a7f8bad51" name="acb204ad9bcd513584bec614a7f8bad51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb204ad9bcd513584bec614a7f8bad51">&#9670;&#160;</a></span>DotProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AVectorType , typename BVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION double openturbine::DotProduct </td>
          <td>(</td>
          <td class="paramtype">const AVectorType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the dot product between two vector views. </p>

</div>
</div>
<a id="a93fd260429a217254a1f7fefd06f1d0c" name="a93fd260429a217254a1f7fefd06f1d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fd260429a217254a1f7fefd06f1d0c">&#9670;&#160;</a></span>DotProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double openturbine::DotProduct </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dot product between two vector views. </p>

</div>
</div>
<a id="ab7ca657b6802690caf59a751895988b7" name="ab7ca657b6802690caf59a751895988b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ca657b6802690caf59a751895988b7">&#9670;&#160;</a></span>dss_numeric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSSHandleType , typename CrsMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::dss_numeric </td>
          <td>(</td>
          <td class="paramtype">DSSHandleType &amp;&#160;</td>
          <td class="paramname"><em>dss_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrsMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6218493b464b10ca4569eb0e85971e9" name="ab6218493b464b10ca4569eb0e85971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6218493b464b10ca4569eb0e85971e9">&#9670;&#160;</a></span>dss_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSSHandleType , typename CrsMatrixType , typename MultiVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::dss_solve </td>
          <td>(</td>
          <td class="paramtype">DSSHandleType &amp;&#160;</td>
          <td class="paramname"><em>dss_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrsMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiVectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiVectorType &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5faae3763d2c59be117c6fb7a48e8289" name="a5faae3763d2c59be117c6fb7a48e8289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faae3763d2c59be117c6fb7a48e8289">&#9670;&#160;</a></span>dss_symbolic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSSHandleType , typename CrsMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::dss_symbolic </td>
          <td>(</td>
          <td class="paramtype">DSSHandleType &amp;&#160;</td>
          <td class="paramname"><em>dss_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CrsMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb44d63028c659a18ee7fd14ac650550" name="aeb44d63028c659a18ee7fd14ac650550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb44d63028c659a18ee7fd14ac650550">&#9670;&#160;</a></span>GenerateGLLPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; openturbine::GenerateGLLPoints </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates Gauss-Lobatto-Legendre (GLL) points for spectral element discretization. </p>
<p>Computes the GLL points, i.e. roots of the Legendre polynomial, using Newton-Raphson iteration. GLL points are optimal interpolation nodes for spectral methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Order of the polynomial interpolation (must be &gt;= 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of GLL points sorted in ascending order, size = order + 1 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if order &lt; 1 </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if Newton-Raphson iteration fails to converge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba008b3bc6e6267dedceab420db6a548" name="aba008b3bc6e6267dedceab420db6a548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba008b3bc6e6267dedceab420db6a548">&#9670;&#160;</a></span>GenerateHollowCircleSection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structopenturbine_1_1BeamSection.html">BeamSection</a> openturbine::GenerateHollowCircleSection </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wall_thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_C</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_C</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_p</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_S</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_S</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_s</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_G</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_G</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_i</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a <a class="el" href="structopenturbine_1_1BeamSection.html">BeamSection</a> with 6x6 mass and stiffness matrices for a hollow circular cross-section. </p>
<p>This is a convenience function specifically for hollow circular sections commonly used in wind turbine towers. It calculates the geometric properties and then calls the general GenerateMassMatrix and GenerateStiffnessMatrix functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Normalized position along beam element [dimensionless] </td></tr>
    <tr><td class="paramname">E</td><td>Young's modulus [Force/Length¬≤] </td></tr>
    <tr><td class="paramname">G</td><td>Shear modulus [Force/Length¬≤] </td></tr>
    <tr><td class="paramname">rho</td><td>Material density [Mass/Length¬≥] </td></tr>
    <tr><td class="paramname">outer_diameter</td><td>Outer diameter of the hollow circle [Length] </td></tr>
    <tr><td class="paramname">wall_thickness</td><td>Wall thickness [Length] </td></tr>
    <tr><td class="paramname">nu</td><td>Poisson's ratio [dimensionless] </td></tr>
    <tr><td class="paramname">x_C</td><td>x-coordinate of elastic centroid relative to reference point [Length] </td></tr>
    <tr><td class="paramname">y_C</td><td>y-coordinate of elastic centroid relative to reference point [Length] </td></tr>
    <tr><td class="paramname">theta_p</td><td>Rotation angle from reference axes to principal bending axes [radians] </td></tr>
    <tr><td class="paramname">x_S</td><td>x-coordinate of shear center relative to reference point [Length] </td></tr>
    <tr><td class="paramname">y_S</td><td>y-coordinate of shear center relative to reference point [Length] </td></tr>
    <tr><td class="paramname">theta_s</td><td>Rotation angle from reference axes to principal shear axes [radians] </td></tr>
    <tr><td class="paramname">x_G</td><td>x-coordinate of center of gravity relative to reference point [Length] </td></tr>
    <tr><td class="paramname">y_G</td><td>y-coordinate of center of gravity relative to reference point [Length] </td></tr>
    <tr><td class="paramname">theta_i</td><td>Rotation angle from reference axes to principal inertia axes [radians]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structopenturbine_1_1BeamSection.html">BeamSection</a> object containing stiffness matrix, mass matrix, and position</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For hollow circular sections, the elastic centroid, shear center, and center of gravity all coincide at the geometric center, so offset parameters are typically zero. </dd>
<dd>
Principal axes align with the reference axes due to circular symmetry. </dd></dl>

</div>
</div>
<a id="a2c12adbb0f9038c2bdd440d524ea57f6" name="a2c12adbb0f9038c2bdd440d524ea57f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c12adbb0f9038c2bdd440d524ea57f6">&#9670;&#160;</a></span>GenerateMassMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; openturbine::GenerateMassMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>I_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>I_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>I_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_G</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_G</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_i</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a 6x6 cross-sectional mass matrix for use in beam elements. </p>
<p>This function constructs the cross-sectional mass matrix that relates the generalized accelerations to the generalized inertial forces in a beam cross-section. Returns the mass matrix at a given point 'O' and w.r.t. given orientation axes based on the values at the center of gravity 'G' and in the inertial axis frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Mass per unit length [Mass/Length] </td></tr>
    <tr><td class="paramname">I_x</td><td>Mass moment of inertia about local x-axis in principal/inertial frame and at center of gravity G [Mass√óLength] </td></tr>
    <tr><td class="paramname">I_y</td><td>Mass moment of inertia about local y-axis in principal/inertial frame and at center of gravity G [Mass√óLength] </td></tr>
    <tr><td class="paramname">I_p</td><td>Polar mass moment of inertia in principal/inertial frame and at center of gravity G (I_x + I_y) [Mass√óLength] </td></tr>
    <tr><td class="paramname">x_G</td><td>x-coordinate of center of gravity relative to reference point i.e. distance FROM O TO G [Length] </td></tr>
    <tr><td class="paramname">y_G</td><td>y-coordinate of center of gravity relative to reference point i.e. distance FROM O TO G [Length] </td></tr>
    <tr><td class="paramname">theta_i</td><td>Rotation angle (around z) FROM reference axes TO principal inertial axes [radians]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>6x6 cross-sectional mass matrix </dd></dl>

</div>
</div>
<a id="ac8826904598850172d0f547e9ec05c38" name="ac8826904598850172d0f547e9ec05c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8826904598850172d0f547e9ec05c38">&#9670;&#160;</a></span>GenerateStiffnessMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; openturbine::GenerateStiffnessMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>EA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>EI_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>EI_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>GKt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>GA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>kys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a 6x6 cross-sectional stiffness matrix for use in beam elements. </p>
<p>This function constructs the cross-sectional stiffness matrix that relates the generalized strains to the generalized forces/moments in a beam cross-section. The matrix accounts for coupling between axial, bending, shear, and torsional deformations due to offset between the elastic centroid and shear center locations. Returns a 6x6 stiffness matrix at the cross section origin 'O', based on inputs at the centroid 'C' and shear center 'S' locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EA</td><td>Axial stiffness (E√óA) [Force] </td></tr>
    <tr><td class="paramname">EI_x</td><td>Bending stiffness around local x-axis in principal frame and at the centroid 'C' [Force √ó Length¬≤] </td></tr>
    <tr><td class="paramname">EI_y</td><td>Bending stiffness around local y-axis in principal frame and at the centroid 'C' [Force √ó Length¬≤] </td></tr>
    <tr><td class="paramname">GKt</td><td>Torsional stiffness around principal frame and at shear center 'S' (G√óJ) [Force √ó Length¬≤] </td></tr>
    <tr><td class="paramname">GA</td><td>Shear stiffness around principal frame and at shear center 'S' (G√óA) [Force] </td></tr>
    <tr><td class="paramname">kxs</td><td>Shear correction factor in x-direction [dimensionless] </td></tr>
    <tr><td class="paramname">kys</td><td>Shear correction factor in y-direction [dimensionless] </td></tr>
    <tr><td class="paramname">x_C</td><td>x-coordinate of elastic centroid relative to reference point i.e. distance FROM 'O' TO 'C' [Length] </td></tr>
    <tr><td class="paramname">y_C</td><td>y-coordinate of elastic centroid relative to reference point i.e. distance FROM 'O' TO 'C' [Length] </td></tr>
    <tr><td class="paramname">theta_p</td><td>Rotation angle (around z) FROM reference axes TO principal bending axes [radians] </td></tr>
    <tr><td class="paramname">x_S</td><td>x-coordinate of shear center relative to reference point i.e. distance FROM 'O' TO 'S' [Length] </td></tr>
    <tr><td class="paramname">y_S</td><td>y-coordinate of shear center relative to reference point i.e. distance FROM 'O' TO 'S' [Length] </td></tr>
    <tr><td class="paramname">theta_s</td><td>Rotation angle (around z) FROM reference axes TO principal shear axes [radians]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>6x6 cross-sectional stiffness matrix </dd></dl>

</div>
</div>
<a id="a382b442cac8b0bcc950d5b66d3268f53" name="a382b442cac8b0bcc950d5b66d3268f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382b442cac8b0bcc950d5b66d3268f53">&#9670;&#160;</a></span>GetNumberOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr size_t openturbine::GetNumberOfNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">ConstraintType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes used/required by the constraint type. </p>

</div>
</div>
<a id="ac8b6f9362da1ff2adc401aebee75d68e" name="ac8b6f9362da1ff2adc401aebee75d68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b6f9362da1ff2adc401aebee75d68e">&#9670;&#160;</a></span>InterpQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename shape_matrix_type , typename node_type , typename qp_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::InterpQuaternion </td>
          <td>(</td>
          <td class="paramtype">const shape_matrix_type &amp;&#160;</td>
          <td class="paramname"><em>shape_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_type &amp;&#160;</td>
          <td class="paramname"><em>node_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const qp_type &amp;&#160;</td>
          <td class="paramname"><em>qp_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb9136254ef248f7b5f0d886d72bfca" name="acbb9136254ef248f7b5f0d886d72bfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb9136254ef248f7b5f0d886d72bfca">&#9670;&#160;</a></span>InterpVector3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename shape_matrix_type , typename node_type , typename qp_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::InterpVector3 </td>
          <td>(</td>
          <td class="paramtype">const shape_matrix_type &amp;&#160;</td>
          <td class="paramname"><em>shape_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_type &amp;&#160;</td>
          <td class="paramname"><em>node_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const qp_type &amp;&#160;</td>
          <td class="paramname"><em>qp_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13e7fae4215fdf08b8bddcc22e56ccdb" name="a13e7fae4215fdf08b8bddcc22e56ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e7fae4215fdf08b8bddcc22e56ccdb">&#9670;&#160;</a></span>InterpVector3Deriv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename shape_matrix_type , typename jacobian_type , typename node_type , typename qp_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::InterpVector3Deriv </td>
          <td>(</td>
          <td class="paramtype">const shape_matrix_type &amp;&#160;</td>
          <td class="paramname"><em>shape_matrix_deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const jacobian_type &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_type &amp;&#160;</td>
          <td class="paramname"><em>node_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const qp_type &amp;&#160;</td>
          <td class="paramname"><em>qp_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a667fba0d91a01b1a395f788b4663667d" name="a667fba0d91a01b1a395f788b4663667d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667fba0d91a01b1a395f788b4663667d">&#9670;&#160;</a></span>InterpVector4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename shape_matrix_type , typename node_type , typename qp_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::InterpVector4 </td>
          <td>(</td>
          <td class="paramtype">const shape_matrix_type &amp;&#160;</td>
          <td class="paramname"><em>shape_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_type &amp;&#160;</td>
          <td class="paramname"><em>node_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const qp_type &amp;&#160;</td>
          <td class="paramname"><em>qp_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae36ce634a21ee775c8246f924dc2fd2d" name="ae36ce634a21ee775c8246f924dc2fd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36ce634a21ee775c8246f924dc2fd2d">&#9670;&#160;</a></span>InterpVector4Deriv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename shape_matrix_type , typename jacobian_type , typename node_type , typename qp_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::InterpVector4Deriv </td>
          <td>(</td>
          <td class="paramtype">const shape_matrix_type &amp;&#160;</td>
          <td class="paramname"><em>shape_matrix_deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const jacobian_type &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_type &amp;&#160;</td>
          <td class="paramname"><em>node_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const qp_type &amp;&#160;</td>
          <td class="paramname"><em>qp_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3ae7ec2f79c8519eb93122773096413" name="ad3ae7ec2f79c8519eb93122773096413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ae7ec2f79c8519eb93122773096413">&#9670;&#160;</a></span>IsIdentityQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openturbine::IsIdentityQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a quaternion is approximately the identity quaternion [1, 0, 0, 0]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion to check </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance for the comparison (default: 1e-12) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the quaternion is approximately the identity quaternion, false otherwise </dd></dl>

</div>
</div>
<a id="a62d02ced85c6d34a155ffe003d33044b" name="a62d02ced85c6d34a155ffe003d33044b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d02ced85c6d34a155ffe003d33044b">&#9670;&#160;</a></span>LagrangePolynomialDerivWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::LagrangePolynomialDerivWeights </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes weights for Lagrange polynomial derivative interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Interpolation nodes (sorted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weights Weights for Lagrange polynomial derivative interpolation (same size as xs) </dd></dl>

</div>
</div>
<a id="a5798912cd717bfcb31c8740afd46d9dc" name="a5798912cd717bfcb31c8740afd46d9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5798912cd717bfcb31c8740afd46d9dc">&#9670;&#160;</a></span>LagrangePolynomialInterpWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::LagrangePolynomialInterpWeights </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes weights for Lagrange polynomial interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Interpolation nodes (sorted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weights Weights for Lagrange polynomial interpolation (same size as xs) </dd></dl>

</div>
</div>
<a id="a2500bd75d55b14e075f84f7d639ad79c" name="a2500bd75d55b14e075f84f7d639ad79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2500bd75d55b14e075f84f7d639ad79c">&#9670;&#160;</a></span>LegendrePolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double openturbine::LegendrePolynomial </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the value of Legendre polynomial of order n at point x. </p>
<p>Uses the recurrence relation for Legendre polynomials: P_n(x) = ((2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x))/n Reference: Deville et al. (2002) "High-Order Methods for Incompressible Fluid Flow" DOI: <a href="https://doi.org/10.1017/CBO9780511546792">https://doi.org/10.1017/CBO9780511546792</a>, Eq. B.1.15, p.446</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Order of the Legendre polynomial (n &gt;= 0) </td></tr>
    <tr><td class="paramname">x</td><td>Point at which to evaluate the polynomial, typically in [-1,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the nth order Legendre polynomial at x </dd></dl>

</div>
</div>
<a id="a1db20fcfb13ca8cebee42efbe709969c" name="a1db20fcfb13ca8cebee42efbe709969c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db20fcfb13ca8cebee42efbe709969c">&#9670;&#160;</a></span>LinearInterp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double openturbine::LinearInterp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes linear interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Value locations </td></tr>
    <tr><td class="paramname">values</td><td>Values at given locations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated value at evaluation point </dd></dl>

</div>
</div>
<a id="a8211d7f6377e8997cc7bc582b0026cf1" name="a8211d7f6377e8997cc7bc582b0026cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8211d7f6377e8997cc7bc582b0026cf1">&#9670;&#160;</a></span>LinearInterpWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::LinearInterpWeights </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes weights for linear interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Evaluation point </td></tr>
    <tr><td class="paramname">xs</td><td>Interpolation nodes (sorted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weights Weights for linear interpolation (same size as xs) </dd></dl>

</div>
</div>
<a id="a0205ddd45198a3c2892ebfb251c18be6" name="a0205ddd45198a3c2892ebfb251c18be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0205ddd45198a3c2892ebfb251c18be6">&#9670;&#160;</a></span>MapGeometricLocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; openturbine::MapGeometricLocations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>geom_locations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps input geometric locations -&gt; normalized domain using linear mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geom_locations</td><td>Input geometric locations (typically in domain [0, 1]), sorted in ascending order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; Mapped/normalized evaluation points in domain [-1, 1] </dd></dl>

</div>
</div>
<a id="a45278089c85b116e991de15af3ac44ce" name="a45278089c85b116e991de15af3ac44ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45278089c85b116e991de15af3ac44ce">&#9670;&#160;</a></span>MapNodePositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; openturbine::MapNodePositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map node positions from [0,1] to [-1,1]. </p>

</div>
</div>
<a id="aeaadd42bbad5c5402c33c5dbdb445179" name="aeaadd42bbad5c5402c33c5dbdb445179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaadd42bbad5c5402c33c5dbdb445179">&#9670;&#160;</a></span>MapSectionPositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; openturbine::MapSectionPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map section positions from [0,1] to [-1,1]. </p>

</div>
</div>
<a id="a3ad27565ccfd45b311fc65fd9a78790b" name="a3ad27565ccfd45b311fc65fd9a78790b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad27565ccfd45b311fc65fd9a78790b">&#9670;&#160;</a></span>Norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double openturbine::Norm </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the norm of a given vector. </p>

</div>
</div>
<a id="ac8b39de2d4c5546c48b34c5f3f8bfa71" name="ac8b39de2d4c5546c48b34c5f3f8bfa71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b39de2d4c5546c48b34c5f3f8bfa71">&#9670;&#160;</a></span>NormalizeQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION Kokkos::Array&lt; double, 4 &gt; openturbine::NormalizeQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Kokkos::Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a quaternion to ensure it is a unit quaternion. </p>
<p>If the length of the quaternion is zero, it returns a default unit quaternion. Otherwise, it normalizes the quaternion and returns the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The input quaternion as a Kokkos::Array&lt;double, 4&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kokkos::Array&lt;double, 4&gt; The normalized quaternion </dd></dl>

</div>
</div>
<a id="a485ef13a60949d64665469a7fa2cf644" name="a485ef13a60949d64665469a7fa2cf644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485ef13a60949d64665469a7fa2cf644">&#9670;&#160;</a></span>NumColsForConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr size_t openturbine::NumColsForConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">ConstraintType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of degrees of freedom prescribed/fixed by the constraint type. </p>

</div>
</div>
<a id="a14ddfd0e99cc8dfae2c642df6d8b1063" name="a14ddfd0e99cc8dfae2c642df6d8b1063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ddfd0e99cc8dfae2c642df6d8b1063">&#9670;&#160;</a></span>NumRowsForConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION constexpr size_t openturbine::NumRowsForConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenturbine.html#a86a41c4e6ed003fa419c858b8e6cd18d">ConstraintType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of degrees of freedom prescribed/fixed by the constraint type. </p>

</div>
</div>
<a id="a46c42f508c32ce963cde7215e5acd063" name="a46c42f508c32ce963cde7215e5acd063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c42f508c32ce963cde7215e5acd063">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION <a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a> openturbine::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenturbine.html#ac4a0c4b14f459d6be7082dd819d5e15c">FreedomSignature</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two freedom signatures using bitwise OR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>First freedom signature </td></tr>
    <tr><td class="paramname">y</td><td>Second freedom signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Combined freedom signature with all DOFs from both inputs enabled </dd></dl>

</div>
</div>
<a id="a55ac2ab5492e98dbb225554c19dc9935" name="a55ac2ab5492e98dbb225554c19dc9935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ac2ab5492e98dbb225554c19dc9935">&#9670;&#160;</a></span>PerformLeastSquaresFitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; double, 3 &gt; &gt; openturbine::PerformLeastSquaresFitting </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; double, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_to_fit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs least squares fitting to determine interpolation coefficients. </p>
<p>Performs least squares fitting to determine interpolation coefficients by solving a dense linear system [A][X] = [B], where [A] is the shape function matrix (p x n), [B] is the input points (n x 3), and [X] is the interpolation coefficients (p x 3)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Number of points representing the polynomial of order p-1 </td></tr>
    <tr><td class="paramname">shape_functions</td><td>Shape function matrix (p x n) </td></tr>
    <tr><td class="paramname">points_to_fit</td><td>x,y,z coordinates of the points to fit (n x 3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation coefficients (p x 3) </dd></dl>

</div>
</div>
<a id="a888000afce26299dbe662ce083412bab" name="a888000afce26299dbe662ce083412bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888000afce26299dbe662ce083412bab">&#9670;&#160;</a></span>PopulateNodeX0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::PopulateNodeX0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::View&lt; double *[7], Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate the node initial position and orientation. </p>

</div>
</div>
<a id="ad04aed28bc5a0aa6e48f1f1d3fdd7590" name="ad04aed28bc5a0aa6e48f1f1d3fdd7590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04aed28bc5a0aa6e48f1f1d3fdd7590">&#9670;&#160;</a></span>PopulateQPCstar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::PopulateQPCstar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::View&lt; double *[6][6], Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>qp_Cstar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate stiffness matrix values at each quadrature point. </p>

</div>
</div>
<a id="aa6c1b8370d0c393e360ce3a358460901" name="aa6c1b8370d0c393e360ce3a358460901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c1b8370d0c393e360ce3a358460901">&#9670;&#160;</a></span>PopulateQPMstar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::PopulateQPMstar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::View&lt; double *[6][6], Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>qp_Mstar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate mass matrix values at each quadrature point. </p>

</div>
</div>
<a id="a4610aa881d666d9e5bddb6a5067339c2" name="a4610aa881d666d9e5bddb6a5067339c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4610aa881d666d9e5bddb6a5067339c2">&#9670;&#160;</a></span>PopulateQPWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::PopulateQPWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::View&lt; double *, Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>qp_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate the integration weights at each quadrature point. </p>

</div>
</div>
<a id="ad4c08713ed08661e503dd8c5b5f16b2b" name="ad4c08713ed08661e503dd8c5b5f16b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c08713ed08661e503dd8c5b5f16b2b">&#9670;&#160;</a></span>PopulateShapeFunctionDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::PopulateShapeFunctionDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::View&lt; double **, Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape_deriv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate shape function derivatives at each quadrature point. </p>

</div>
</div>
<a id="aa12109372869418dcc0abca332b0d6c5" name="aa12109372869418dcc0abca332b0d6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12109372869418dcc0abca332b0d6c5">&#9670;&#160;</a></span>PopulateShapeFunctionValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::PopulateShapeFunctionValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1BeamElement.html">BeamElement</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structopenturbine_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kokkos::View&lt; double **, Kokkos::LayoutStride, Kokkos::HostSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape_interp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate shape function values at each quadrature point. </p>

</div>
</div>
<a id="aa87b3510b483752bb7b465629e7180c4" name="aa87b3510b483752bb7b465629e7180c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87b3510b483752bb7b465629e7180c4">&#9670;&#160;</a></span>PredictNextState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::PredictNextState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac477866f341264e321869bc6d75c0852" name="ac477866f341264e321869bc6d75c0852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac477866f341264e321869bc6d75c0852">&#9670;&#160;</a></span>ProjectPointsToTargetPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; double, 3 &gt; &gt; openturbine::ProjectPointsToTargetPolynomial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; double, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects 3D points from a given (lower) polynomial representation to a target (higher) polynomial representation. </p>
<p>This function maps a set of 3D points defined at nodes of a polynomial of order source_order to corresponding points at nodes of a polynomial of order target_order (typically higher than the source order) using Least-Squares Finite Element (LSFE) shape functions.</p>
<p>Primary use case: The primary application of this function is to increase the number of points from a lower-order geometric representation to the higher-order representation required for spectral finite element analysis. This enables the use of high-order methods while allowing geometry to be defined with fewer points initially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_inputs</td><td>Number of points in the source polynomial representation </td></tr>
    <tr><td class="paramname">num_outputs</td><td>Number of points in the target polynomial representation </td></tr>
    <tr><td class="paramname">input_points</td><td>3D coordinates of points in the source representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::array&lt;double, 3&gt;&gt;<ul>
<li>Coordinates of the projected 3D points at the target polynomial nodes </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aed4cf00f5ca47c84e3062aca99acb262" name="aed4cf00f5ca47c84e3062aca99acb262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4cf00f5ca47c84e3062aca99acb262">&#9670;&#160;</a></span>QuaternionCompose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion1 , typename Quaternion2 , typename QuaternionN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::QuaternionCompose </td>
          <td>(</td>
          <td class="paramtype">const Quaternion1 &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Quaternion2 &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QuaternionN &amp;&#160;</td>
          <td class="paramname"><em>qn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes (i.e. multiplies) two quaternions and stores the result in a third quaternion. </p>

</div>
</div>
<a id="aa98638bb9e8aed28dc1e2d23a74e5dcc" name="aa98638bb9e8aed28dc1e2d23a74e5dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98638bb9e8aed28dc1e2d23a74e5dcc">&#9670;&#160;</a></span>QuaternionCompose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; openturbine::QuaternionCompose </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes (i.e. multiplies) two quaternions and returns the result. </p>

</div>
</div>
<a id="ad1a13950d555c0d5711557490e098167" name="ad1a13950d555c0d5711557490e098167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a13950d555c0d5711557490e098167">&#9670;&#160;</a></span>QuaternionDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::QuaternionDerivative </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the derivative of a quaternion and stores the result in a 3x4 matrix. </p>

</div>
</div>
<a id="a92ca747f32ff26a16f5338a76bd5ce76" name="a92ca747f32ff26a16f5338a76bd5ce76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ca747f32ff26a16f5338a76bd5ce76">&#9670;&#160;</a></span>QuaternionInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename QuaternionInput , typename QuaternionOutput &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::QuaternionInverse </td>
          <td>(</td>
          <td class="paramtype">const QuaternionInput &amp;&#160;</td>
          <td class="paramname"><em>q_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuaternionOutput &amp;&#160;</td>
          <td class="paramname"><em>q_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of a quaternion. </p>

</div>
</div>
<a id="a6031a1228dd8c9d2d5340a579a2b7c8c" name="a6031a1228dd8c9d2d5340a579a2b7c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6031a1228dd8c9d2d5340a579a2b7c8c">&#9670;&#160;</a></span>QuaternionToRotationMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename RotationMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::QuaternionToRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RotationMatrix &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result. </p>

</div>
</div>
<a id="a17b5090e9b8913c75677a4c99c106537" name="a17b5090e9b8913c75677a4c99c106537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b5090e9b8913c75677a4c99c106537">&#9670;&#160;</a></span>QuaternionToRotationMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt; openturbine::QuaternionToRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 4x1 quaternion to a 3x3 rotation matrix and returns the result. </p>

</div>
</div>
<a id="a9c2a49772ed693d1c27ac4e630d4fbe5" name="a9c2a49772ed693d1c27ac4e630d4fbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2a49772ed693d1c27ac4e630d4fbe5">&#9670;&#160;</a></span>QuaternionToRotationVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::QuaternionToRotationVector </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 3-D rotation vector from provided 4-D quaternion, i.e. the logarithmic map. </p>

</div>
</div>
<a id="aaedcc4f8cff54577c5845a63f86442ea" name="aaedcc4f8cff54577c5845a63f86442ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedcc4f8cff54577c5845a63f86442ea">&#9670;&#160;</a></span>QuaternionToRotationVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; openturbine::QuaternionToRotationVector </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 3-D rotation vector from provided 4-D quaternion. </p>

</div>
</div>
<a id="a824a1ec66835921088c4dfc658322095" name="a824a1ec66835921088c4dfc658322095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824a1ec66835921088c4dfc658322095">&#9670;&#160;</a></span>ReadStateFromFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::ReadStateFromFile </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8777e77beabff02f607c8252c2cefd4" name="ad8777e77beabff02f607c8252c2cefd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8777e77beabff02f607c8252c2cefd4">&#9670;&#160;</a></span>ResetConstraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::ResetConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c05476e233e348498c9719f6571f8fc" name="a9c05476e233e348498c9719f6571f8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c05476e233e348498c9719f6571f8fc">&#9670;&#160;</a></span>ResetSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::ResetSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13cc33bc27f5f5b4f66cf4f33ed1db98" name="a13cc33bc27f5f5b4f66cf4f33ed1db98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cc33bc27f5f5b4f66cf4f33ed1db98">&#9670;&#160;</a></span>RotateMatrix6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; openturbine::RotateMatrix6 </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; double, 6 &gt;, 6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac72faf839870c2324c1201669f4874fd" name="ac72faf839870c2324c1201669f4874fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72faf839870c2324c1201669f4874fd">&#9670;&#160;</a></span>RotateVectorByQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Quaternion , typename View1 , typename View2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::RotateVectorByQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const View1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const View2 &amp;&#160;</td>
          <td class="paramname"><em>v_rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates provided vector by provided <em>unit</em> quaternion and returns the result. </p>

</div>
</div>
<a id="a1e80ed01a40636e26fda570566c8712f" name="a1e80ed01a40636e26fda570566c8712f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e80ed01a40636e26fda570566c8712f">&#9670;&#160;</a></span>RotateVectorByQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; openturbine::RotateVectorByQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates provided vector by provided <em>unit</em> quaternion and returns the result. </p>

</div>
</div>
<a id="ad506ebe71e7afd1ba6b40eeafd959d9f" name="ad506ebe71e7afd1ba6b40eeafd959d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad506ebe71e7afd1ba6b40eeafd959d9f">&#9670;&#160;</a></span>RotationMatrixToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; openturbine::RotationMatrixToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 3x3 rotation matrix to a 4x1 quaternion and returns the result, see <a href="https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/">https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</a> for implementation details. </p>

</div>
</div>
<a id="afe7f9cb90556cfb4258d7c0e7407df3c" name="afe7f9cb90556cfb4258d7c0e7407df3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7f9cb90556cfb4258d7c0e7407df3c">&#9670;&#160;</a></span>RotationVectorToQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; openturbine::RotationVectorToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map. </p>

</div>
</div>
<a id="a9f941e64c14f9edcfb3d8f62efc34633" name="a9f941e64c14f9edcfb3d8f62efc34633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f941e64c14f9edcfb3d8f62efc34633">&#9670;&#160;</a></span>RotationVectorToQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector , typename Quaternion &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::RotationVectorToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Quaternion &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 4-D quaternion from provided 3-D rotation vector, i.e. the exponential map. </p>

</div>
</div>
<a id="aab7f7a5476c025fc05f72cd313619ec9" name="aab7f7a5476c025fc05f72cd313619ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7f7a5476c025fc05f72cd313619ec9">&#9670;&#160;</a></span>SolveSystem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::SolveSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a401e812f3359217f90799a34c5fb37f4" name="a401e812f3359217f90799a34c5fb37f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401e812f3359217f90799a34c5fb37f4">&#9670;&#160;</a></span>Step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openturbine::Step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to complete a single time step in the dynamic FEA simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>Simulation step parameters including time step size and convergence criteria </td></tr>
    <tr><td class="paramname">solver</td><td><a class="el" href="structopenturbine_1_1Solver.html" title="This object manages the assembly and solution of linear system arising from the generalized-alpha bas...">Solver</a> object containing system matrices and solution methods </td></tr>
    <tr><td class="paramname">elements</td><td>Collection of elements (beams, masses etc.) in the FE mesh </td></tr>
    <tr><td class="paramname">state</td><td>Current state of the system (positions, velocities, accelerations etc.) </td></tr>
    <tr><td class="paramname">constraints</td><td>System constraints and their associated data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the step converged within the maximum allowed iterations, otherwise false </dd></dl>

</div>
</div>
<a id="a09592817ae601310d569910e7603cc4a" name="a09592817ae601310d569910e7603cc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09592817ae601310d569910e7603cc4a">&#9670;&#160;</a></span>TangentTwistToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 4 &gt; openturbine::TangentTwistToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 4-D quaternion from provided tangent vector and twist (degrees) about tangent. </p>

</div>
</div>
<a id="adee5cd7f43dea8ac0f9a706cca255e62" name="adee5cd7f43dea8ac0f9a706cca255e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee5cd7f43dea8ac0f9a706cca255e62">&#9670;&#160;</a></span>UnitVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; double, 3 &gt; openturbine::UnitVector </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UnitVector returns the unit vector of the given vector. </p>

</div>
</div>
<a id="a7db6a0642536770dfd1c9864d28b4b99" name="a7db6a0642536770dfd1c9864d28b4b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db6a0642536770dfd1c9864d28b4b99">&#9670;&#160;</a></span>UpdateConstraintPrediction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateConstraintPrediction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab85467e8fa5b8b0757ac1749a12f6640" name="ab85467e8fa5b8b0757ac1749a12f6640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85467e8fa5b8b0757ac1749a12f6640">&#9670;&#160;</a></span>UpdateConstraintVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateConstraintVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1Constraints.html">Constraints</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab135fd3e4a55b8eafb693d63778d6d0b" name="ab135fd3e4a55b8eafb693d63778d6d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab135fd3e4a55b8eafb693d63778d6d0b">&#9670;&#160;</a></span>UpdateStatePrediction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateStatePrediction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Solver.html">Solver</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aceb0d78408970e2f5707eb6da6c65656" name="aceb0d78408970e2f5707eb6da6c65656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb0d78408970e2f5707eb6da6c65656">&#9670;&#160;</a></span>UpdateSystemVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateSystemVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Elements.html">Elements</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97ea1c4346ac0e80a41e7986ff1c4ee9" name="a97ea1c4346ac0e80a41e7986ff1c4ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ea1c4346ac0e80a41e7986ff1c4ee9">&#9670;&#160;</a></span>UpdateSystemVariablesBeams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateSystemVariablesBeams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Beams.html">Beams</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>beams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae90ea3c8e7997ac4f2ac3057fd591a8c" name="ae90ea3c8e7997ac4f2ac3057fd591a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90ea3c8e7997ac4f2ac3057fd591a8c">&#9670;&#160;</a></span>UpdateSystemVariablesMasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateSystemVariablesMasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Masses.html">Masses</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>masses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd3707277127727af6fe2bf96e37b744" name="abd3707277127727af6fe2bf96e37b744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3707277127727af6fe2bf96e37b744">&#9670;&#160;</a></span>UpdateSystemVariablesSprings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateSystemVariablesSprings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1Springs.html">Springs</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>springs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bce4a0ea133697b8166de3f32939445" name="a6bce4a0ea133697b8166de3f32939445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bce4a0ea133697b8166de3f32939445">&#9670;&#160;</a></span>UpdateTangentOperator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::UpdateTangentOperator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1StepParameters.html">StepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27b4aa8d797ea86827404834f2a0173d" name="a27b4aa8d797ea86827404834f2a0173d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b4aa8d797ea86827404834f2a0173d">&#9670;&#160;</a></span>VecTilde()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KOKKOS_INLINE_FUNCTION void openturbine::VecTilde </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 3x1 vector to a 3x3 skew-symmetric matrix and returns the result. </p>

</div>
</div>
<a id="a62af0f1efb9ba7a0937e98e71f34e0ef" name="a62af0f1efb9ba7a0937e98e71f34e0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62af0f1efb9ba7a0937e98e71f34e0ef">&#9670;&#160;</a></span>WriteStateToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openturbine::WriteStateToFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenturbine_1_1State.html">State</a>&lt; DeviceType &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8b0e60f1da391382388f44fc056935a1" name="a8b0e60f1da391382388f44fc056935a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0e60f1da391382388f44fc056935a1">&#9670;&#160;</a></span>kConvergenceTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double openturbine::kConvergenceTolerance {std::numeric_limits&lt;double&gt;::epsilon()}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tolerance for Newton's method to machine precision. </p>

</div>
</div>
<a id="a48906c8285184b9678d6334ad3458ef3" name="a48906c8285184b9678d6334ad3458ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48906c8285184b9678d6334ad3458ef3">&#9670;&#160;</a></span>kMaxIterations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t openturbine::kMaxIterations {1000}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of iterations allowed for Newton's method. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 - Present, MIT License.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>